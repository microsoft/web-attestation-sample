// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function commonjsRequire(path) { throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.') } var cryptoECCExports = {}; var cryptoECC$1 = { get exports() { return cryptoECCExports }, set exports(v) { cryptoECCExports = v } }; var utilitiesExports = {}; var utilities = { get exports() { return utilitiesExports }, set exports(v) { utilitiesExports = v } }; var hasRequiredUtilities; function requireUtilities() { if (hasRequiredUtilities) return utilitiesExports; hasRequiredUtilities = 1; (function (module, exports) { var msrcryptoUtilities = function () { var encodingChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; var setterSupport = function () { try { Object.defineProperty({}, "oncomplete", {}); return true } catch (ex) { return false } }(); function consoleLog(text) { if ("console" in self && "log" in console) { console.log(text) } } function toBase64(data, base64Url) { var dataType = getObjectType(data); if (dataType !== "Array" && dataType !== "Uint8Array" && dataType !== "ArrayBuffer") { throw new Error("invalid input") } var output = ""; var input = toArray(data); if (!base64Url) { base64Url = false } var char1, char2, char3, enc1, enc2, enc3, enc4; var i; for (i = 0; i < input.length; i += 3){ char1 = input[i]; char2 = input[i + 1]; char3 = input[i + 2]; enc1 = char1 >> 2; enc2 = (char1 & 3) << 4 | char2 >> 4; enc3 = (char2 & 15) << 2 | char3 >> 6; enc4 = char3 & 63; if (isNaN(char2)) { enc3 = enc4 = 64 } else if (isNaN(char3)) { enc4 = 64 } output = output + encodingChars.charAt(enc1) + encodingChars.charAt(enc2) + encodingChars.charAt(enc3) + encodingChars.charAt(enc4) } if (base64Url) { return output.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "") } return output } function base64ToBytes(encodedString) { encodedString = encodedString.replace(/-/g, "+").replace(/_/g, "/"); while (encodedString.length % 4 !== 0) { encodedString += "=" } var output = []; var char1, char2, char3; var enc1, enc2, enc3, enc4; var i; encodedString = encodedString.replace(/[^A-Za-z0-9\+\/\=]/g, ""); for (i = 0; i < encodedString.length; i += 4){ enc1 = encodingChars.indexOf(encodedString.charAt(i)); enc2 = encodingChars.indexOf(encodedString.charAt(i + 1)); enc3 = encodingChars.indexOf(encodedString.charAt(i + 2)); enc4 = encodingChars.indexOf(encodedString.charAt(i + 3)); char1 = enc1 << 2 | enc2 >> 4; char2 = (enc2 & 15) << 4 | enc3 >> 2; char3 = (enc3 & 3) << 6 | enc4; output.push(char1); if (enc3 !== 64) { output.push(char2) } if (enc4 !== 64) { output.push(char3) } } return output } function getObjectType(object) { return Object.prototype.toString.call(object).slice(8, -1) } function bytesToHexString(bytes, separate) { var result = ""; if (typeof separate === "undefined") { separate = false } for (var i = 0; i < bytes.length; i++){ if (separate && i % 4 === 0 && i !== 0) { result += "-" } var hexval = bytes[i].toString(16).toUpperCase(); if (hexval.length === 1) { result += "0" } result += hexval } return result } function bytesToInt32(bytes, index) { index = index || 0; return bytes[index] << 24 | bytes[index + 1] << 16 | bytes[index + 2] << 8 | bytes[index + 3] } function hexToBytesArray(hexString) { hexString = hexString.replace(/\-/g, ""); var result = []; while (hexString.length >= 2) { result.push(parseInt(hexString.substring(0, 2), 16)); hexString = hexString.substring(2, hexString.length) } return result } function clone(object) { var newObject = {}; for (var propertyName in object) { if (object.hasOwnProperty(propertyName)) { newObject[propertyName] = object[propertyName] } } return newObject } function unpackData(base64String, arraySize, toUint32s) { var bytes = base64ToBytes(base64String), data = [], i; if (isNaN(arraySize)) { return bytes } else { for (i = 0; i < bytes.length; i += arraySize){ data.push(bytes.slice(i, i + arraySize)) } } if (toUint32s) { for (i = 0; i < data.length; i++){ data[i] = (data[i][0] << 24) + (data[i][1] << 16) + (data[i][2] << 8) + data[i][3] } } return data } function int32ToBytes(int32) { return [int32 >>> 24 & 255, int32 >>> 16 & 255, int32 >>> 8 & 255, int32 & 255] } function int32ArrayToBytes(int32Array) { var result = []; for (var i = 0; i < int32Array.length; i++){ result = result.concat(int32ToBytes(int32Array[i])) } return result } function xorVectors(a, b, res) { var length = Math.min(a.length, b.length), res = res || new Array(length); for (var i = 0; i < length; i += 1){ res[i] = a[i] ^ b[i] } return res } function getVector(length, fillValue) { if (isNaN(fillValue)) { fillValue = 0 } var res = new Array(length); for (var i = 0; i < length; i += 1){ res[i] = fillValue } return res } function toArray(typedArray) { if (!typedArray) { return [] } if (typedArray.pop) { return typedArray } if (getObjectType(typedArray) === "ArrayBuffer") { typedArray = new Uint8Array(typedArray) } else if (typedArray.BYTES_PER_ELEMENT > 1) { typedArray = new Uint8Array(typedArray.buffer) } if (typedArray.length === 1) { return [typedArray[0]] } if (typedArray.length < 65536) { return Array.apply(null, typedArray) } var returnArray = new Array(typedArray.length); for (var i = 0; i < typedArray.length; i++){ returnArray[i] = typedArray[i] } return returnArray } function padEnd(array, value, finalLength) { while (array.length < finalLength) { array.push(value) } return array } function padFront(array, value, finalLength) { while (array.length < finalLength) { array.unshift(value) } return array } function arraysEqual(array1, array2) { var result = true; if (array1.length !== array2.length) { result = false } for (var i = 0; i < array1.length; i++){ if (array1[i] !== array2[i]) { result = false } } return result } function checkParam(param, type, errorMessage) { if (!param) { throw new Error(errorMessage) } if (type && getObjectType(param) !== type) { throw new Error(errorMessage) } return true } function stringToBytes(text) { var encodedBytes = []; for (var i = 0, j = 0; i < text.length; i++){ var charCode = text.charCodeAt(i); if (charCode < 128) { encodedBytes[j++] = charCode } else if (charCode < 2048) { encodedBytes[j++] = charCode >>> 6 | 192; encodedBytes[j++] = charCode & 63 | 128 } else if (charCode < 55296 || charCode > 57343) { encodedBytes[j++] = charCode >>> 12 | 224; encodedBytes[j++] = charCode >>> 6 & 63 | 128; encodedBytes[j++] = charCode & 63 | 128 } else { charCode = (charCode - 55296) * 1024 + (text.charCodeAt(++i) - 56320) + 65536; encodedBytes[j++] = charCode >>> 18 | 240; encodedBytes[j++] = charCode >>> 12 & 63 | 128; encodedBytes[j++] = charCode >>> 6 & 63 | 128; encodedBytes[j++] = charCode & 63 | 128 } } return encodedBytes } function bytesToString(textBytes) { var result = "", charCode; textBytes = toArray(textBytes); for (var i = 0; i < textBytes.length;){ var encodedChar = textBytes[i++]; if (encodedChar < 128) { charCode = encodedChar } else if (encodedChar < 224) { charCode = (encodedChar << 6) + textBytes[i++] - 12416 } else if (encodedChar < 240) { charCode = (encodedChar << 12) + (textBytes[i++] << 6) + textBytes[i++] - 925824 } else { charCode = (encodedChar << 18) + (textBytes[i++] << 12) + (textBytes[i++] << 6) + textBytes[i++] - 63447168 } if (charCode > 65535) { var surrogateHigh = Math.floor((charCode - 65536) / 1024) + 55296; var surrogateLow = (charCode - 65536) % 1024 + 56320; result += String.fromCharCode(surrogateHigh, surrogateLow); continue } result += String.fromCharCode(charCode) } return result } function error(name, message) { var err = Error(message); err.name = name; throw err } function isBytes(array) { if (!(array instanceof Array)) return false; for (var i = 0; i < array.length; i++){ var d = array[i]; if (!isInteger(d) || d > 255 || d < 0) return false } return true } function isInteger(value) { return typeof value === "number" && isFinite(value) && Math.floor(value) === value } function createProperty(parentObject, propertyName, initialValue, getterFunction, setterFunction) { if (!setterSupport) { parentObject[propertyName] = initialValue; return } var setGet = {}; getterFunction && (setGet.get = getterFunction); setterFunction && (setGet.set = setterFunction); Object.defineProperty(parentObject, propertyName, setGet) } return { consoleLog: consoleLog, toBase64: toBase64, fromBase64: base64ToBytes, checkParam: checkParam, getObjectType: getObjectType, bytesToHexString: bytesToHexString, bytesToInt32: bytesToInt32, stringToBytes: stringToBytes, bytesToString: bytesToString, unpackData: unpackData, hexToBytesArray: hexToBytesArray, int32ToBytes: int32ToBytes, int32ArrayToBytes: int32ArrayToBytes, toArray: toArray, arraysEqual: arraysEqual, clone: clone, xorVectors: xorVectors, padEnd: padEnd, padFront: padFront, getVector: getVector, error: error, isBytes: isBytes, isInteger: isInteger, createProperty: createProperty, setterSupport: setterSupport } }(); { module.exports = msrcryptoUtilities } })(utilities); return utilitiesExports } var cryptoMathExports = {}; var cryptoMath = { get exports() { return cryptoMathExports }, set exports(v) { cryptoMathExports = v } }; (function (module, exports) { function msrcryptoMath() { var DIGIT_BITS = 24; var DIGIT_NUM_BYTES = Math.floor(DIGIT_BITS / 8); var DIGIT_MASK = (1 << DIGIT_BITS) - 1; var DIGIT_BASE = 1 << DIGIT_BITS; var DIGIT_MAX = DIGIT_MASK; var DIG_INV = 1 / DIGIT_BASE; var DIGIT_SCALER = [1, 256]; for (var ds = 2; ds <= DIGIT_NUM_BYTES; ds++){ DIGIT_SCALER[ds] = DIGIT_SCALER[ds - 1] * 256 } var Zero = [0]; var One = [1]; function createArray(parameter) { var i, array = null; if (!arguments.length || typeof arguments[0] === "number") { array = new Array(parameter); for (i = 0; i < parameter; i += 1){ array[i] = 0 } } else if (typeof arguments[0] === "object") { array = new Array(parameter.length); for (i = 0; i < parameter.length; i += 1){ array[i] = parameter[i] } } return array } function stringToDigits(numberStr, radix) { numberStr = numberStr.replace(/^\s+|\s+$/g, ""); var num = [0]; var buffer = [0]; radix = radix || 10; for (var i = 0; i < numberStr.length; i += 1){ var char = parseInt(numberStr[i], radix); if (isNaN(char)) { throw new Error("Failed to convert string to integer in radix " + radix.toString()) } multiply(num, radix, buffer); add(buffer, [char], num); normalizeDigitArray(num) } return num } function digitsToString(digits, radix) { radix = radix || 10; if (DIGIT_BASE <= radix) { throw new Error("DIGIT_BASE is smaller than RADIX; cannot convert.") } var wordLength = digits.length; var quotient = []; var remainder = []; var temp1 = []; var temp2 = []; var divisor = []; var a = []; var i; var sb = ""; var pad = "0"; divisor[0] = radix; while (Math.floor(DIGIT_BASE / divisor[0]) >= radix) { divisor[0] = divisor[0] * radix; pad = pad.concat("0") } for (i = 0; i < wordLength; i += 1){ a[i] = digits[i] } do { var allZeros = true; for (i = 0; i < a.length; i += 1){ if (a[i] !== 0) { allZeros = false; break } } if (allZeros) { break } divRem(a, divisor, quotient, remainder, temp1, temp2); normalizeDigitArray(quotient, a.length, true); var newDigits = remainder[0].toString(radix); sb = pad.substring(0, pad.length - newDigits.length) + newDigits + sb; var swap = a; a = quotient; quotient = swap } while (true); while (sb.length !== 0 && sb[0] === "0") { sb = sb.substring(1, sb.length) } if (sb.length === 0) { sb = "0" } return sb } function computeBitArray(bytes) { var out = createArray(bytes.length * 8); var bitLength = 0; var i = bytes.length - 1; while (i >= 0) { var j = 0; while (j < 8) { var mask = 1 << j; var bit = (bytes[i] & mask) === mask ? 1 : 0; var thisBitIndex = 8 * (bytes.length - i - 1) + j; if (bit === 1) { bitLength = thisBitIndex + 1 } out[thisBitIndex] = bit; j += 1 } i-- } return out.slice(0, bitLength) } function bitScanForward(digit) { var index = 0; for (var i = 0; i < DIGIT_BITS; i++){ index = Math.max(index, -(digit >>> i & 1) & i) } return index } function highestSetBit(bytes) { var i = 0; var bitLength = 0; while (i < bytes.length) { if (bitLength === 0) { var j = 7; while (j >= 0 && bitLength === 0) { var mask = 1 << j; if ((bytes[i] & mask) === mask) { bitLength = j + 1 } j-- } } else { bitLength += 8 } i += 1 } return bitLength } function fixedWindowRecode(digits, windowSize, t) { digits = digits.slice(); var recodedDigits = [], windowSizeBits = Math.pow(2, windowSize), windowSizeMinus1Bits = Math.pow(2, windowSize - 1); for (var i = 0; i < t; i++){ recodedDigits[i] = digits[0] % windowSizeBits - windowSizeMinus1Bits; digits[0] = digits[0] - recodedDigits[i]; cryptoMath.shiftRight(digits, digits, windowSize - 1) } recodedDigits[i] = digits[0]; return recodedDigits } function fixedWindowRecode2(digits, windowSize) { var digLen = digits.length; new Array(digLen * DIGIT_BITS); var i = 0, j = 0, k = 0, r = 0, dig, result = new Array(Math.ceil(digLen * DIGIT_BITS / windowSize)); for (k = 0, result[0] = 0; i < digLen; i++){ for (j = 0, dig = digits[i]; j < DIGIT_BITS; j++, dig >>>= 1){ if (k === windowSize) { result[++r] = 0; k = 0 } result[r] += (dig & 1) << k++ } } return result } function copyArray(source, sourceIndex, destination, destIndex, length) { while (length-- > 0) { destination[destIndex + length] = source[sourceIndex + length] } } function isZero(array) { var i, result = 0; for (i = 0; i < array.length; i += 1){ result = result | array[i] } return !result } function isEven(array) { return (array[0] & 1) === 0 } function sequenceEqual(left, right) { var equal = left.length === right.length; for (var i = 0; i < Math.min(left.length, right.length); i += 1){ if (left[i] !== right[i]) { equal = false } } return equal } function bytesToDigits(bytes) { var arrayLength = Math.floor((bytes.length + DIGIT_NUM_BYTES - 1) / DIGIT_NUM_BYTES); var array = new Array(arrayLength); array[0] = 0; var digit = 0, index = 0, scIndex = 0; for (var i = bytes.length - 1; i >= 0; i--){ digit = digit + DIGIT_SCALER[scIndex++] * (bytes[i] & 255); if (DIGIT_SCALER[scIndex] === DIGIT_BASE) { scIndex = 0; array[index++] = digit; digit = 0 } } if (digit !== 0) { array[index] = digit } while (array[--arrayLength] == null) { array[arrayLength] = 0 } return array } function digitsToBytes(digits, trim, minTrimLength) { var i, j, byte1; var bytes = [0]; if (typeof trim === "undefined") { trim = true } for (i = 0; i < digits.length; i += 1){ byte1 = digits[i]; for (j = 0; j < DIGIT_NUM_BYTES; j += 1){ bytes[i * DIGIT_NUM_BYTES + j] = byte1 & 255; byte1 = Math.floor(byte1 / 256) } } bytes.reverse(); if (minTrimLength === undefined) { minTrimLength = 1 } if (trim) { while (bytes.length > minTrimLength && bytes[0] === 0) { bytes.shift() } } return bytes } function intToDigits(value, numDigits) { if (typeof numDigits === "undefined") { if (value <= 1) { numDigits = 1 } else { var numBits = Math.log(value) / Math.LN2; numDigits = Math.ceil(numBits / DIGIT_BITS) } } var digitRepresentation = []; while (value > 0) { digitRepresentation.push(value % DIGIT_BASE); value = Math.floor(value / DIGIT_BASE) } while (digitRepresentation.length < numDigits) { digitRepresentation.push(0) } return digitRepresentation } function mswIndex(digits) { for (var i = digits.length - 1; i >= 0; i--){ if (digits[i] !== undefined && digits[i] !== 0) { return i } } return digits[0] === 0 ? -1 : 0 } function compareDigits(left, right) { var result = 0, val, i; for (i = 0; i < Math.max(left.length, right.length); i++){ val = ~~left[i] - ~~right[i]; result = val + (result & -!val) } return result } function normalizeDigitArray(digits, length, pad) { var i = mswIndex(digits); digits.length = length || i + 1; if (pad) { while (++i < digits.length) { digits[i] = 0 } } if (digits.length <= 0) { digits[0] = 0; digits.length = 1 } return digits } function shiftRight(source, destination, bits, length) { if (bits === undefined) { bits = 1 } else if (bits >= DIGIT_BITS || bits < 0) { throw new Error("Invalid bit count for shiftRight") } if (length === undefined) { length = source.length } var n = length - 1; var leftShiftBitCount = DIGIT_BITS - bits; for (var i = 0; i < n; i++){ destination[i] = (source[i + 1] << leftShiftBitCount | source[i] >>> bits) & DIGIT_MASK } destination[n] = source[n] >>> bits } function shiftLeft(source, destination, bits, length) { if (bits === undefined) { bits = 1 } else if (bits >= DIGIT_BITS || bits < 0) { throw new Error("bit count must be smaller than DIGIT_BITS and positive in shiftLeft") } if (length === undefined) { length = source.length } var rightShiftBitCount = DIGIT_BITS - bits; destination[length] = source[length - 1] >>> DIGIT_BITS - bits || destination[length]; for (var i = length - 1; i > 0; i--){ destination[i] = (source[i] << bits | source[i - 1] >>> rightShiftBitCount) & DIGIT_MASK } destination[0] = source[0] << bits & DIGIT_MASK } function add(addend1, addend2, sum) { var shortArray = addend1; var longArray = addend2; if (addend2.length < addend1.length) { shortArray = addend2; longArray = addend1 } var s = shortArray.length; var carry = 0; var i; for (i = 0; i < s; i += 1){ carry += shortArray[i] + longArray[i]; sum[i] = carry & DIGIT_MASK; carry = carry >> DIGIT_BITS } for (i = s; i < longArray.length; i += 1){ carry += longArray[i]; sum[i] = carry & DIGIT_MASK; carry = carry >> DIGIT_BITS } sum.length = longArray.length; if (carry !== 0) { sum[i] = carry & DIGIT_MASK } return carry } function subtract(minuend, subtrahend, difference) { var s = subtrahend.length; if (minuend.length < subtrahend.length) { s = mswIndex(subtrahend) + 1; if (minuend.length < s) { throw new Error("Subtrahend is longer than minuend, not supported.") } } var i, carry = 0; for (i = 0; i < s; i += 1){ carry += minuend[i] - subtrahend[i]; difference[i] = carry & DIGIT_MASK; carry = carry >> DIGIT_BITS } while (i < minuend.length) { carry += minuend[i]; difference[i++] = carry & DIGIT_MASK; carry = carry >> DIGIT_BITS } return carry } function multiply(a, b, p) { b = typeof b === "number" ? [b] : b; var i, j, k, l, c, t1, t2, alen = a.length, blen = b.length, bi; for (i = 0; i < alen + blen; i += 1){ p[i] = 0 } i = 0; l = 0; var maxRounds = 31; var ks = 0; while (i < blen) { l = Math.min(l + maxRounds, blen); for (; i < l; i++){ bi = b[i]; for (j = 0; j < alen; j++){ p[i + j] += a[j] * bi } } c = 0; for (k = ks; k < i + alen; k++){ t1 = p[k] + c; t2 = t1 & DIGIT_MASK; p[k] = t2; c = (t1 - t2) * DIG_INV } p[k] = c; ks += maxRounds } p.length = alen + blen; return p } function divRem(dividend, divisor, quotient, remainder, temp1, temp2) { var m = mswIndex(dividend) + 1; var n = mswIndex(divisor) + 1; var qhat, rhat, carry, p, t, i, j; if (m < n) { copyArray(dividend, 0, remainder, 0, dividend.length); remainder.length = dividend.length; normalizeDigitArray(remainder); quotient[0] = 0; quotient.length = 1; return } else if (n === 0 || n === 1 && divisor[n - 1] === 0) { throw new Error("Division by zero.") } else if (n === 1) { t = divisor[0]; rhat = 0; for (j = m - 1; j >= 0; j--){ p = rhat * DIGIT_BASE + dividend[j]; quotient[j] = p / t & DIGIT_MASK; rhat = p - quotient[j] * t & DIGIT_MASK } quotient.length = m; normalizeDigitArray(quotient); remainder[0] = rhat; remainder.length = 1; return } var s = DIGIT_BITS - 1 - bitScanForward(divisor[n - 1]); var vn = temp1 || []; vn.length = n; shiftLeft(divisor, vn, s, n); var un = temp2 || []; un.length = m; shiftLeft(dividend, un, s, m); un[m] = un[m] || 0; quotient.length = m - n + 1; remainder.length = n; for (j = m - n; j >= 0; j--){ qhat = Math.floor((un[j + n] * DIGIT_BASE + un[j + n - 1]) / vn[n - 1]); rhat = un[j + n] * DIGIT_BASE + un[j + n - 1] - qhat * vn[n - 1]; while (true) { if (qhat >= DIGIT_BASE || qhat * vn[n - 2] > rhat * DIGIT_BASE + un[j + n - 2]) { qhat = qhat - 1; rhat = rhat + vn[n - 1]; if (rhat < DIGIT_BASE) { continue } } break } carry = 0; for (i = 0; i < n; i++){ p = qhat * vn[i]; t = un[i + j] - carry - (p & DIGIT_MASK); un[i + j] = t & DIGIT_MASK; carry = Math.floor(p / DIGIT_BASE) - Math.floor(t / DIGIT_BASE) } t = un[j + n] - carry; un[j + n] = t & DIGIT_MASK; quotient[j] = qhat & DIGIT_MASK; if (t < 0) { quotient[j] = quotient[j] - 1; carry = 0; for (i = 0; i < n; i++){ t = un[i + j] + vn[i] + carry; un[i + j] = t & DIGIT_MASK; carry = t >> DIGIT_BITS } un[j + n] = un[j + n] + carry & DIGIT_MASK } } for (i = 0; i < n; i++){ remainder[i] = (un[i] >>> s | un[i + 1] << DIGIT_BITS - s) & DIGIT_MASK } normalizeDigitArray(quotient); normalizeDigitArray(remainder) } function reduce(number, modulus, remainder, temp1, temp2) { var quotient = []; divRem(number, modulus, quotient, remainder, temp1, temp2); return remainder } function modMul(multiplicand, multiplier, modulus, product, temp1, temp2) { var quotient = []; multiply(multiplicand, multiplier, quotient); divRem(quotient, modulus, quotient, product, temp1, temp2); return product } function eea(a, b, upp, vpp, rpp) { var rp; if (isZero(a)) { copyArray(b, 0, rpp, 0, b.length); rpp.length = b.length; return 0 } else if (isZero(b)) { copyArray(a, 0, rpp, 0, a.length); rpp.length = a.length; return 0 } else if (compareDigits(a, b) < 0) { rp = a.slice(0); copyArray(b, 0, rpp, 0, b.length); rpp.length = b.length } else { rp = b.slice(0); copyArray(a, 0, rpp, 0, a.length); rpp.length = a.length } normalizeDigitArray(rpp); normalizeDigitArray(rp); var q = new Array(rpp.length); var r = new Array(rpp.length); var v = new Array(rpp.length); var vppPresent = vpp !== undefined; var vp; if (vppPresent) { vp = new Array(rpp.length); vp[0] = 1; vp.length = 1; vpp[0] = 0; vpp.length = 1 } var up; var u = new Array(rpp.length); var uppPresent = upp !== undefined; if (uppPresent) { up = new Array(rpp.length); up[0] = 0; up.length = 1; upp[0] = 1; upp.length = 1 } var k = -1; var upp_out = upp; var vpp_out = vpp; var rpp_out = rpp; var save; while (!isZero(rp)) { divRem(rpp, rp, q, r, u, v); if (uppPresent) { multiply(q, up, u); add(u, upp, u); normalizeDigitArray(u); save = upp; upp = up; up = u; u = save } if (vppPresent) { multiply(q, vp, v); add(v, vpp, v); normalizeDigitArray(v); save = vpp; vpp = vp; vp = v; v = save } save = rpp; rpp = rp; rp = r; r = save; k++ } if (uppPresent) { copyArray(upp, 0, upp_out, 0, upp.length); upp_out.length = upp.length } if (vppPresent) { copyArray(vpp, 0, vpp_out, 0, vpp.length); vpp_out.length = vpp.length } copyArray(rpp, 0, rpp_out, 0, rpp.length); rpp_out.length = rpp.length; return k } function gcd(a, b, output) { var aa = a; var bb = b; if (compareDigits(a, b) > 0) { aa = b; bb = a } eea(aa, bb, undefined, undefined, output); return normalizeDigitArray(output) } function modInv(a, n, aInv, pad) { var upp = new Array(n.length); var vpp = new Array(n.length); var rpp = new Array(n.length); var k = eea(a, n, vpp, upp, rpp); aInv = aInv || []; if (compareDigits(rpp, One) !== 0) { aInv[0] = NaN; aInv.length = 1 } else { if ((k & 1) === 1) { subtract(n, upp, aInv) } else { copyArray(upp, 0, aInv, 0, upp.length); aInv.length = upp.length } if (pad) { normalizeDigitArray(aInv, n.length, true) } else { normalizeDigitArray(aInv) } } return aInv } function modInvCT(a, n, aInv, pad) { var nMinus2 = []; aInv = aInv || []; subtract(n, [2], nMinus2); modExp(a, nMinus2, n, aInv); normalizeDigitArray(aInv); return aInv } function modExp(base, exponent, modulus, result) { result = result || []; if (compareDigits(exponent, Zero) === 0) { result[0] = 1 } else if (compareDigits(exponent, One) === 0) { copyArray(base, 0, result, 0, base.length); result.length = base.length } else { var montmul = new MontgomeryMultiplier(modulus); normalizeDigitArray(base, montmul.s, true); montmul.modExp(base, exponent, result); result.length = modulus.length } return result } function MontgomeryMultiplier(modulus, context) { function computeM0Prime(m0) { var m0Pr = 1; var a = 2; var b = 3; var c = b & m0; for (var i = 2; i <= DIGIT_BITS; i += 1){ if (a < c) { m0Pr += a } a = a << 1; b = b << 1 | 1; c = m0 * m0Pr & b } var result = (~m0Pr & DIGIT_MASK) + 1; return result } function montgomeryMultiply(multiplicand, multiplier, result, ctx) { ctx = ctx || this; var m = ctx.m, s = m.length, mPrime = ctx.mPrime, m0 = ctx.m0, rightI, r0, q, i = 0, j, jm1, t1, t2, carry, rounds = 0; var temp = createArray(s + 2); while (i < s) { rounds = Math.min(s, rounds + 16); for (; i < rounds;){ rightI = ~~multiplier[i]; r0 = temp[0] + multiplicand[0] * rightI; q = (r0 & DIGIT_MASK) * mPrime & DIGIT_MASK; temp[1] += (m0 * q + r0) * DIG_INV | 0; for (j = 1, jm1 = 0; j < s; jm1 = j, j += 1){ temp[jm1] = temp[j] + m[j] * q + multiplicand[j] * rightI } temp[jm1] = temp[j]; temp[j] = 0; i++ } carry = 0; for (j = 0; j < s; j++){ t1 = temp[j] + carry; t2 = t1 & DIGIT_MASK; temp[j] = t2; carry = (t1 - t2) * DIG_INV } temp[j] = carry } for (i = 0; i < s; i += 1){ result[i] = temp[i] } result.length = s; var needSubtract = +(cryptoMath.compareDigits(temp, m) > 0); cryptoMath.subtract(result, m, ctx.temp2); ctSetArray(needSubtract, result, ctx.temp2); return } function convertToMontgomeryForm(digits) { if (digits.length < this.s) { digits.length = this.s; for (var i = 0; i < this.s; i++){ digits[i] = isNaN(digits[i]) ? 0 : digits[i] } } var result = createArray(digits.length); this.montgomeryMultiply(digits, this.rSquaredModm, result); for (i = 0; i < this.s; i += 1){ digits[i] = result[i] } } function convertToStandardForm(digits) { this.montgomeryMultiply(digits, this.one, this.temp1); for (var i = 0; i < this.s; i += 1){ digits[i] = this.temp1[i] } } function optimalWindowSize(length) { var i = 2, t1, t0, bits = length * DIGIT_BITS; t0 = 4 + Math.ceil(bits / 2) * 3 + 1; do { i++; t1 = t0; t0 = Math.pow(2, i) + Math.ceil(bits / i) * (i + 1) + 1 } while (t0 < t1); return i - 1 } function modExp(base, exponent, result, skipSideChannel) { skipSideChannel = !!skipSideChannel; var windowBits = optimalWindowSize(exponent.length); var i, j, expBits = fixedWindowRecode2(exponent, windowBits).reverse(), partialResult = this.rModM.slice(0), baseTableLen = Math.pow(2, windowBits), bt = baseTable; bt.length = baseTableLen; bt[0] = this.rModM; for (i = 1; i < baseTableLen; i++){ bt[i] = []; multiply(bt[i - 1], base, bt[i]); this.reduce(bt[i]) } var tableVal = []; var exp; for (i = 0; i < expBits.length; i++){ for (j = 0; j < windowBits; j++){ this.montgomeryMultiply(partialResult, partialResult, partialResult) } exp = expBits[i]; skipSideChannel ? tableVal = bt[exp] : getTableEntry(bt, exp, tableVal); this.montgomeryMultiply(partialResult, tableVal, partialResult) } this.montgomeryMultiply(partialResult, this.one, result); return result } function getTableEntry(bt, exp, tableVal) { var z, t, mask, tableEntry, k; for (z = 0; z < bt[0].length; z++){ tableVal[z] = 0 } for (t = 0; t < bt.length; t++){ tableEntry = bt[t]; mask = -(exp === t); for (k = 0; k < tableEntry.length; k++){ tableVal[k] = tableVal[k] | tableEntry[k] & mask } } } function ctSetArray(condition, a, b) { var bMask = -condition; var aMask = ~bMask; for (var i = 0; i < a.length; i++){ a[i] = a[i] & aMask | b[i] & bMask } } function reduce(x, result) { var k = this.m.length, q1, q2, q3, r1, r2, i, needSubtract, temp = []; result = result || x; q1 = x.slice(k - 1); q2 = []; multiply(q1, this.mu, q2); q3 = q2.slice(k + 1); r1 = x.slice(0, k + 1); r2 = []; multiply(q3, m, r2); r2 = r2.slice(0, k + 1); r1[k + 1] = compareDigits(r1, r2) >>> 31; for (i = 0; i < result.length; i++){ result[i] = 0 } subtract(r1, r2, result); needSubtract = +(compareDigits(result, m) > 0); cryptoMath.subtract(result, m, temp); ctSetArray(needSubtract, result, temp); normalizeDigitArray(result); return } function computeContext(modulus) { var s = modulus.length; var m0 = modulus[0]; var ctx = { m: modulus, mPrime: computeM0Prime(m0), m0: m0, temp1: createArray(2 * s + 1), temp2: createArray(2 * s + 1) }; var R = createArray(modulus.length * 2); R[R.length] = 1; ctx.mu = []; divRem(R, modulus, ctx.mu, []); var quotient = createArray(2 * s + 1); var rRemainder = createArray(s + 1); var temp1 = createArray(2 * s + 1); var temp2 = createArray(2 * s + 1); var rDigits = rRemainder; rDigits[s] = 1; divRem(rDigits, modulus, quotient, rRemainder, temp1, temp2); ctx.rModM = normalizeDigitArray(rRemainder, s, true); var rSquaredModm = createArray(2 * s + 1); var rSquaredDigits = rSquaredModm; rSquaredDigits[s * 2] = 1; divRem(rSquaredDigits, modulus, quotient, rSquaredModm, temp1, temp2); ctx.rSquaredModm = normalizeDigitArray(rSquaredModm, s, true); ctx.rCubedModm = createArray(s); montgomeryMultiply(rSquaredModm, rSquaredModm, ctx.rCubedModm, ctx); return ctx } context = context || computeContext(modulus); var m = context.m; var mu = context.mu; var m0 = context.m0; var s = m.length; var zeros = createArray(s + 1); var one = zeros.slice(0, s); one[0] = 1; var mPrime = context.mPrime; var rModM = context.rModM; var rSquaredModm = context.rSquaredModm; var rCubedModm = context.rCubedModm; var temp1 = createArray(2 * s + 1); var temp2 = createArray(2 * s + 1); var baseTable = new Array(4); baseTable[0] = rModM; baseTable[1] = new Array(s); baseTable[2] = new Array(s); baseTable[3] = new Array(s); return { m: m, m0: m0, mPrime: mPrime, mu: mu, rSquaredModm: rSquaredModm, s: s, rModM: rModM, rCubedModm: rCubedModm, one: one, temp1: temp1, temp2: temp2, convertToMontgomeryForm: convertToMontgomeryForm, convertToStandardForm: convertToStandardForm, montgomeryMultiply: montgomeryMultiply, modExp: modExp, reduce: reduce, ctx: context } } function IntegerGroup(modulusBytes) { var m_modulus = bytesToDigits(modulusBytes); var m_digitWidth = m_modulus.length; var m_zero = intToDigits(0, m_digitWidth); var m_one = intToDigits(1, m_digitWidth); var temp0 = createArray(m_digitWidth); var temp1 = createArray(m_digitWidth); var montmul = new MontgomeryMultiplier(m_modulus); function createElementFromBytes(bytes) { var digits = bytesToDigits(bytes); if (cryptoMath.compareDigits(digits, this.m_modulus) >= 0) { throw new Error("The number provided is not an element of this group") } normalizeDigitArray(digits, this.m_digitWidth, true); return integerGroupElement(digits, this) } function createElementFromInteger(integer) { var digits = intToDigits(integer, this.m_digitWidth); return integerGroupElement(digits, this) } function createElementFromDigits(digits) { cryptoMath.normalizeDigitArray(digits, this.m_digitWidth, true); return integerGroupElement(digits, this) } function equals(otherGroup) { return compareDigits(this.m_modulus, otherGroup.m_modulus) === 0 } function add(addend1, addend2, sum) { var i; var s = this.m_digitWidth; var result = sum.m_digits; cryptoMath.add(addend1.m_digits, addend2.m_digits, result); var mask = (compareDigits(result, this.m_modulus) >>> 31) - 1 & DIGIT_MASK; var carry = 0; for (i = 0; i < s; i += 1){ carry = result[i] - (this.m_modulus[i] & mask) + carry; result[i] = carry & DIGIT_MASK; carry = carry >> DIGIT_BITS } result.length = s } function subtract(leftElement, rightElement, outputElement) { var i, s = this.m_digitWidth; var result = outputElement.m_digits; var carry = cryptoMath.subtract(leftElement.m_digits, rightElement.m_digits, outputElement.m_digits); if (carry === -1) { carry = 0; for (i = 0; i < s; i += 1){ carry += result[i] + this.m_modulus[i]; result[i] = carry & DIGIT_MASK; carry = carry >> DIGIT_BITS } } } function inverse(element, outputElement) { cryptoMath.modInv(element.m_digits, this.m_modulus, outputElement.m_digits) } function multiply(multiplicand, multiplier, product) { return cryptoMath.modMul(multiplicand.m_digits, multiplier.m_digits, this.m_modulus, product.m_digits, temp0, temp1) } function modexp(valueElement, exponent, outputElement) { outputElement = outputElement || integerGroupElement([], this); if (compareDigits(exponent, m_zero) === 0) { outputElement.m_digits = intToDigits(1, this.m_digitWidth) } else if (compareDigits(exponent, m_one) === 0) { for (var i = 0; i < valueElement.m_digits.length; i++){ outputElement.m_digits[i] = valueElement.m_digits[i] } outputElement.m_digits.length = valueElement.m_digits.length } else { this.montmul.modExp(valueElement.m_digits, exponent, outputElement.m_digits); outputElement.m_digits.length = this.montmul.s } return outputElement } function integerGroupElement(digits, group) { return { m_digits: digits, m_group: group, equals: function (element) { return compareDigits(this.m_digits, element.m_digits) === 0 && this.m_group.equals(this.m_group, element.m_group) } } } return { m_modulus: m_modulus, m_digitWidth: m_digitWidth, montmul: montmul, createElementFromInteger: createElementFromInteger, createElementFromBytes: createElementFromBytes, createElementFromDigits: createElementFromDigits, equals: equals, add: add, subtract: subtract, multiply: multiply, inverse: inverse, modexp: modexp } } return { DIGIT_BITS: DIGIT_BITS, DIGIT_NUM_BYTES: DIGIT_NUM_BYTES, DIGIT_MASK: DIGIT_MASK, DIGIT_BASE: DIGIT_BASE, DIGIT_MAX: DIGIT_MAX, Zero: Zero, One: One, normalizeDigitArray: normalizeDigitArray, bytesToDigits: bytesToDigits, stringToDigits: stringToDigits, digitsToString: digitsToString, intToDigits: intToDigits, digitsToBytes: digitsToBytes, isZero: isZero, isEven: isEven, shiftRight: shiftRight, shiftLeft: shiftLeft, compareDigits: compareDigits, bitLength: highestSetBit, fixedWindowRecode: fixedWindowRecode, IntegerGroup: IntegerGroup, add: add, subtract: subtract, multiply: multiply, divRem: divRem, reduce: reduce, modInv: modInv, modInvCT: modInvCT, modExp: modExp, modMul: modMul, MontgomeryMultiplier: MontgomeryMultiplier, gcd: gcd, createArray: createArray, sequenceEqual: sequenceEqual, swapEndianness: function (bytes) { return bytes.reverse() }, computeBitArray: computeBitArray } } var cryptoMath = cryptoMath || msrcryptoMath(); { module.exports = cryptoMath } })(cryptoMath); (function (module, exports) { var cryptoMath; var msrcryptoUtilities; if (typeof commonjsRequire === "function") { msrcryptoUtilities = requireUtilities(); cryptoMath = cryptoMathExports } function MsrcryptoECC() { var btd = cryptoMath.bytesToDigits; var utils = msrcryptoUtilities; var setterSupport = utils.setterSupport; function createArray(parameter) { var i, array = null; if (!arguments.length || typeof arguments[0] === "number") { array = []; for (i = 0; i < parameter; i += 1){ array[i] = 0 } } else if (typeof arguments[0] === "object") { array = []; for (i = 0; i < parameter.length; i += 1){ array[i] = parameter[i] } } return array } var EllipticCurveFp = function (p1, a1, b1, order, gx, gy) { var fieldStorageBitLength = p1.length; var generator = EllipticCurvePointFp(this, false, gx, gy, null, false); return { p: p1, a: a1, b: b1, order: order, generator: generator, allocatePointStorage: function () { return EllipticCurvePointFp(this, false, cryptoMath.intToDigits(0, fieldStorageBitLength), cryptoMath.intToDigits(0, fieldStorageBitLength)) }, createPointAtInfinity: function () { return EllipticCurvePointFp(this, true, cryptoMath.intToDigits(0, fieldStorageBitLength), cryptoMath.intToDigits(0, fieldStorageBitLength)) } } }; var createWeierstrassCurve = function (curveData) { var newCurve = new EllipticCurveFp(btd(curveData.p), btd(curveData.a), btd(curveData.b), btd(curveData.order), btd(curveData.gx), btd(curveData.gy)); newCurve.type = curveData.type; newCurve.name = curveData.name; newCurve.generator.curve = newCurve; return newCurve }; var createTedCurve = function (curveData) { var newCurve = new EllipticCurveFp(btd(curveData.p), btd(curveData.a), btd(curveData.d), btd(curveData.order), btd(curveData.gx), btd(curveData.gy)); newCurve.type = curveData.type; if (newCurve.type === 1) { newCurve.d = newCurve.b.slice(); delete newCurve.b } newCurve.rbits = curveData.info[2]; newCurve.name = curveData.name; newCurve.generator.curve = newCurve; return newCurve }; var EllipticCurvePointFp = function (curve, isInfinity, x, y, z, isInMontgomeryForm) { var returnObj; if (typeof z === "undefined") { z = null } if (typeof isInMontgomeryForm === "undefined") { isInMontgomeryForm = false } function equals(ellipticCurvePointFp) { if (!ellipticCurvePointFp) { return false } if (returnObj.isInfinity && ellipticCurvePointFp.isInfinity) { return true } if (returnObj.z === null && ellipticCurvePointFp.z !== null) { return false } if (returnObj.z !== null && ellipticCurvePointFp.z === null) { return false } if (returnObj.z === null) { return cryptoMath.compareDigits(returnObj.x, ellipticCurvePointFp.x) === 0 && cryptoMath.compareDigits(returnObj.y, ellipticCurvePointFp.y) === 0 && returnObj.isInMontgomeryForm === ellipticCurvePointFp.isInMontgomeryForm } return cryptoMath.compareDigits(returnObj.x, ellipticCurvePointFp.x) === 0 && cryptoMath.compareDigits(returnObj.y, ellipticCurvePointFp.y) === 0 && cryptoMath.compareDigits(returnObj.z, ellipticCurvePointFp.z) === 0 && returnObj.isInMontgomeryForm === ellipticCurvePointFp.isInMontgomeryForm } function copyTo(source, destination) { destination.curve = source.curve; destination.x = source.x.slice(); destination.y = source.y.slice(); if (source.z !== null) { destination.z = source.z.slice() } else { destination.z = null } setterSupport || (destination.isAffine = source.isAffine); destination.isInMontgomeryForm = source.isInMontgomeryForm; destination.isInfinity = source.isInfinity; if (!destination.equals(source)) { throw new Error("Instances should be equal.") } } function clone() { var clonePoint = EllipticCurvePointFp(returnObj.curve, returnObj.isInfinity, createArray(returnObj.x), createArray(returnObj.y), returnObj.z ? createArray(returnObj.z) : null, returnObj.isInMontgomeryForm); returnObj.ta && (clonePoint.ta = createArray(returnObj.ta)); returnObj.tb && (clonePoint.tb = createArray(returnObj.tb)); return clonePoint } returnObj = { equals: function (ellipticCurvePointFp) { return equals(ellipticCurvePointFp) }, copy: function (destination) { copyTo(this, destination); return }, clone: function () { return clone() } }; utils.createProperty(returnObj, "curve", curve, function () { return curve }, function (val) { curve = val }); utils.createProperty(returnObj, "x", x, function () { return x }, function (val) { x = val }); utils.createProperty(returnObj, "y", y, function () { return y }, function (val) { y = val }); utils.createProperty(returnObj, "z", z, function () { return z }, function (val) { z = val }); utils.createProperty(returnObj, "isInMontgomeryForm", isInMontgomeryForm, function () { return isInMontgomeryForm }, function (val) { isInMontgomeryForm = val }); utils.createProperty(returnObj, "isInfinity", isInfinity, function () { return isInfinity }, function (val) { isInfinity = val }); utils.createProperty(returnObj, "isAffine", z === null, function () { return z === null }); return returnObj }; var EllipticCurveOperatorFp = function (curve) { var tedCurve = curve.type === 1; var fieldElementWidth = curve.p.length; var montgomeryMultiplier = cryptoMath.MontgomeryMultiplier(curve.p); var montgomerizedA = curve.a.slice(); montgomeryMultiplier.convertToMontgomeryForm(montgomerizedA); var aequalsZero = cryptoMath.isZero(curve.a); var one = cryptoMath.One; var onemontgomery = createArray(fieldElementWidth); onemontgomery[0] = 1; montgomeryMultiplier.convertToMontgomeryForm(onemontgomery); var group = cryptoMath.IntegerGroup(cryptoMath.digitsToBytes(montgomeryMultiplier.m), true); var temp0 = createArray(fieldElementWidth); var temp1 = createArray(fieldElementWidth); var temp2 = createArray(fieldElementWidth); var temp3 = createArray(fieldElementWidth); var temp4 = createArray(fieldElementWidth); var temp5 = createArray(fieldElementWidth); var temp6 = createArray(fieldElementWidth); var temp7 = createArray(fieldElementWidth); var swap0 = createArray(fieldElementWidth); var conversionTemp0 = createArray(fieldElementWidth); var conversionTemp1 = createArray(fieldElementWidth); var conversionTemp2 = createArray(fieldElementWidth); function modSub(left, right, result) { var resultElement = group.createElementFromInteger(0); resultElement.m_digits = result; group.subtract(group.createElementFromDigits(left), group.createElementFromDigits(right), resultElement) } function modAdd(left, right, result) { var resultElement = group.createElementFromInteger(0); resultElement.m_digits = result; group.add(group.createElementFromDigits(left), group.createElementFromDigits(right), resultElement) } function modDivByTwo(dividend, result) { var s = dividend.length; var modulus = curve.p; if ((dividend[0] & 1) === 1) { var carry = 0; for (var i = 0; i < s; i += 1){ carry += dividend[i] + modulus[i]; result[i] = carry & cryptoMath.DIGIT_MASK; carry = carry >>> cryptoMath.DIGIT_BITS } carry = carry << cryptoMath.DIGIT_BITS - 1; cryptoMath.shiftRight(result, result); result[s - 1] |= carry } else { cryptoMath.shiftRight(dividend, result) } } function montgomeryMultiply(left, right, result) { montgomeryMultiplier.montgomeryMultiply(left, right, result) } function montgomerySquare(left, result) { montgomeryMultiplier.montgomeryMultiply(left, left, result) } function doubleAequalsNeg3(point, outputPoint) { if (point.isInfinity) { outputPoint.isInfinity = true; return } montgomerySquare(point.z, temp1); montgomeryMultiply(point.z, point.y, temp4); modAdd(point.x, temp1, temp2); modSub(point.x, temp1, temp1); outputPoint.z = temp4.slice(); montgomeryMultiply(temp1, temp2, temp3); modDivByTwo(temp3, temp2); modAdd(temp3, temp2, temp1); montgomerySquare(point.y, temp2); montgomerySquare(temp1, temp4); montgomeryMultiply(point.x, temp2, temp3); modSub(temp4, temp3, temp4); modSub(temp4, temp3, outputPoint.x); modSub(temp3, outputPoint.x, temp4); montgomerySquare(temp2, temp3); montgomeryMultiply(temp1, temp4, temp2); modSub(temp2, temp3, outputPoint.y); outputPoint.isInfinity = false; outputPoint.isInMontgomeryForm = true } function doubleAequals0(point, outputPoint) { if (point.isInfinity) { outputPoint.isInfinity = true; return } montgomerySquare(point.y, temp3); montgomerySquare(point.x, temp4); modAdd(temp4, temp4, temp0); modAdd(temp0, temp4, temp4); montgomeryMultiply(point.x, temp3, temp5); montgomerySquare(temp3, temp0); modDivByTwo(temp4, temp1); montgomerySquare(temp1, temp3); montgomeryMultiply(point.y, point.z, swap0); for (var i = 0; i < swap0.length; i += 1){ outputPoint.z[i] = swap0[i] } modSub(temp3, temp5, outputPoint.x); modSub(outputPoint.x, temp5, outputPoint.x); modSub(temp5, outputPoint.x, temp4); montgomeryMultiply(temp1, temp4, temp2); modSub(temp2, temp0, outputPoint.y); outputPoint.isInfinity = false; outputPoint.isInMontgomeryForm = true } function generatePrecomputationTable(w, generatorPoint) { var validationPoint = generatorPoint.clone(); convertToStandardForm(validationPoint); if (!validatePoint(validationPoint)) { throw new Error("Invalid Parameter") } var pointJac = generatorPoint.clone(); convertToJacobianForm(pointJac); var tablePos = [generatorPoint.clone()]; var qJac = pointJac.clone(); var px2 = pointJac.clone(); double(pointJac, px2); convertToAffineForm(px2); var qAff; for (var i = 1; i < Math.pow(2, w - 2); i++){ mixedAdd(qJac, px2, qJac); qAff = qJac.clone(); convertToAffineForm(qAff); tablePos[i] = qAff } return tablePos } function double(point, outputPoint) { if (typeof point === "undefined") { throw new Error("point undefined") } if (typeof outputPoint === "undefined") { throw new Error("outputPoint undefined") } if (point.isAffine) { throw new Error("Given point was in Affine form. Use convertToJacobian() first.") } if (!point.isInMontgomeryForm) { throw new Error("Given point must be in Montgomery form. Use montgomeryize() first.") } if (aequalsZero) { doubleAequals0(point, outputPoint) } else { doubleAequalsNeg3(point, outputPoint) } } function mixedDoubleAdd(jacobianPoint, affinePoint, outputPoint) { if (jacobianPoint.isInfinity) { affinePoint.copy(outputPoint); this.convertToJacobianForm(outputPoint); return } if (affinePoint.isInfinity) { jacobianPoint.copy(outputPoint); return } montgomerySquare(jacobianPoint.z, temp5); montgomeryMultiply(jacobianPoint.z, temp5, temp6); montgomeryMultiply(affinePoint.x, temp5, temp4); montgomeryMultiply(affinePoint.y, temp6, temp5); modSub(temp4, jacobianPoint.x, temp1); modSub(temp5, jacobianPoint.y, temp2); if (cryptoMath.isZero(temp1)) { if (cryptoMath.isZero(temp2)) { double(jacobianPoint, outputPoint); mixedAdd(outputPoint, affinePoint, outputPoint); return } else { outputPoint.x = jacobianPoint.x.slice(0); outputPoint.y = jacobianPoint.y.slice(0); outputPoint.z = jacobianPoint.z.slice(0); return } } montgomerySquare(temp2, temp4); montgomerySquare(temp1, temp6); montgomeryMultiply(temp6, jacobianPoint.x, temp5); montgomeryMultiply(temp1, temp6, temp0); modSub(temp4, temp5, temp3); modSub(temp3, temp5, temp3); montgomeryMultiply(jacobianPoint.z, temp1, temp4); modSub(temp3, temp5, temp3); montgomeryMultiply(temp0, jacobianPoint.y, temp6); modSub(temp3, temp0, temp3); if (cryptoMath.isZero(temp3)) { for (i = 0; i < outputPoint.x.length; i++){ outputPoint.x[i] = 0; outputPoint.y[i] = 0; outputPoint.z[i] = 0 } outputPoint.y[0] = 1; return } modAdd(temp6, temp6, temp1); montgomeryMultiply(temp4, temp3, outputPoint.z); montgomeryMultiply(temp2, temp3, temp4); montgomerySquare(temp3, temp0); modAdd(temp1, temp4, temp1); montgomeryMultiply(temp0, temp5, temp4); montgomerySquare(temp1, temp7); montgomeryMultiply(temp0, temp3, temp5); modSub(temp7, temp4, outputPoint.x); modSub(outputPoint.x, temp4, outputPoint.x); modSub(outputPoint.x, temp5, outputPoint.x); modSub(outputPoint.x, temp4, temp3); montgomeryMultiply(temp5, temp6, temp0); montgomeryMultiply(temp1, temp3, temp4); modSub(temp4, temp0, outputPoint.y); outputPoint.isInfinity = false; outputPoint.isInMontgomeryForm = true } function mixedAdd(jacobianPoint, affinePoint, outputPoint) { if (jacobianPoint === null) { throw new Error("jacobianPoint") } if (affinePoint === null) { throw new Error("affinePoint") } if (outputPoint === null) { throw new Error("outputPoint") } if (jacobianPoint.curve !== affinePoint.curve || jacobianPoint.curve !== outputPoint.curve) { throw new Error("All points must be from the same curve object.") } if (jacobianPoint.isAffine) { throw new Error("Given jacobianPoint was in Affine form. Use ConvertToJacobian()\t                     before calling DoubleJacobianAddAffinePoints().") } if (!affinePoint.isAffine) { throw new Error("Given affinePoint was in Jacobian form. Use ConvertToAffine() before \t                     calling DoubleJacobianAddAffinePoints().") } if (outputPoint.isAffine) { throw new Error("Given jacobianPoint was in Jacobian form. Use ConvertToJacobian() before \t                     calling DoubleJacobianAddAffinePoints().") } if (!jacobianPoint.isInMontgomeryForm) { throw new Error("Jacobian point must be in Montgomery form") } if (!affinePoint.isInMontgomeryForm) { throw new Error("Affine point must be in Montgomery form") } if (jacobianPoint.isInfinity) { affinePoint.copy(outputPoint); this.convertToJacobianForm(outputPoint); return } if (affinePoint.isInfinity) { jacobianPoint.copy(outputPoint); return } montgomerySquare(jacobianPoint.z, temp1); montgomeryMultiply(temp1, jacobianPoint.z, temp2); montgomeryMultiply(temp1, affinePoint.x, temp3); montgomeryMultiply(temp2, affinePoint.y, temp4); modSub(temp3, jacobianPoint.x, temp1); modSub(temp4, jacobianPoint.y, temp2); var i; for (i = 0; i < temp1.length; i += 1){ if (temp1[i] !== 0) { montgomeryMultiply(jacobianPoint.z, temp1, temp0); for (var j = 0; j < fieldElementWidth; j += 1){ outputPoint.z[j] = temp0[j] } montgomerySquare(temp1, temp3); montgomeryMultiply(temp3, temp1, temp4); montgomeryMultiply(temp3, jacobianPoint.x, temp5); modAdd(temp5, temp5, temp1); montgomerySquare(temp2, outputPoint.x); modSub(outputPoint.x, temp1, outputPoint.x); modSub(outputPoint.x, temp4, outputPoint.x); modSub(temp5, outputPoint.x, temp3); montgomeryMultiply(temp2, temp3, temp5); montgomeryMultiply(jacobianPoint.y, temp4, temp6); modSub(temp5, temp6, outputPoint.y); outputPoint.isInfinity = false; outputPoint.isInMontgomeryForm = true; return } } for (i = 0; i < temp2.length; i += 1){ if (temp2[i] !== 0) { outputPoint.isInfinity = true; outputPoint.isInMontgomeryForm = true; return } } affinePoint.copy(outputPoint); this.convertToJacobianForm(outputPoint); this.double(outputPoint, outputPoint); outputPoint.isInMontgomeryForm = true } function scalarMultiply(k, point, outputPoint, multiplyBy4) { if (point.isInfinity || cryptoMath.isZero(k)) { outputPoint.isInfinity = true; return } if (cryptoMath.compareDigits(k, curve.order) >= 0) { throw new Error("The scalar k must be in the range 1 <= k < order.") } k = k.slice(); if (point.curve.type === 1) { var pointIsEP = typeof point.ta !== "undefined"; if (!pointIsEP) { convertToExtendedProjective(point) } scalarMultiplyTed(k, point, outputPoint, multiplyBy4); if (!pointIsEP) { normalizeTed(point) } } else { var pointIsMF = point.isInMontgomeryForm, outputIsMF = outputPoint.isInMontgomeryForm, outputIsAffine = outputPoint.isAffine; if (!pointIsMF) { convertToMontgomeryForm(point) } if (!outputIsMF) { convertToMontgomeryForm(outputPoint) } scalarMultiplyW(k, point, outputPoint); if (outputIsAffine) { convertToAffineForm(outputPoint) } if (!pointIsMF) { convertToStandardForm(point) } if (!outputIsMF) { convertToStandardForm(outputPoint) } } return } function scalarMultiplyW(k, point, outputPoint) { var validationPoint = point.clone(); convertToStandardForm(validationPoint); if (!validatePoint(validationPoint)) { throw new Error("Invalid Parameters.") } var odd = k[0] & 1, tempk = []; modSub(point.curve.order, k, tempk); for (i = 0; i < k.length; i++){ k[i] = odd - 1 & (k[i] ^ tempk[i]) ^ k[i] } var w = fieldElementWidth <= 8 ? 5 : 6; var m = point.curve.p.length * cryptoMath.DIGIT_BITS; var t = Math.ceil(m / (w - 1)); var kDigits = cryptoMath.fixedWindowRecode(k, w, t); var Tm = generatePrecomputationTable(w, point); var position = Math.floor(Math.abs(kDigits[t]) - 1) / 2; var Q = Tm[position].clone(); convertToJacobianForm(Q); for (var i = t - 1; i >= 0; i--){ for (var j = 0; j < w - 2; j++){ double(Q, Q) } position = Math.floor((Math.abs(kDigits[i]) - 1) / 2); var L = tableLookupW(Tm, position); modSub(L.curve.p, L.y, tempk); var mask = -(kDigits[i] >>> 31); for (var n = 0; n < L.y.length; n++){ L.y[n] = L.y[n] & ~mask | tempk[n] & mask } mixedDoubleAdd(Q, L, Q) } modSub(point.curve.p, Q.y, tempk); for (i = 0; i < Q.y.length; i++){ Q.y[i] = odd - 1 & (Q.y[i] ^ tempk[i]) ^ Q.y[i] } Q.copy(outputPoint); return } function tableLookupW(table, index) { var mask, L; for (var i = 0; i < table.length; i++){ mask = +(i === index); L = [L, table[i].clone()][mask] } return L } function negate(point, outputPoint) { if (point !== outputPoint) { point.copy(outputPoint) } modSub(point.curve.p, point.y, outputPoint.y) } function convertToMontgomeryForm(point) { if (point.isInMontgomeryForm) { throw new Error("The given point is already in Montgomery form.") } if (!point.isInfinity) { montgomeryMultiplier.convertToMontgomeryForm(point.x); montgomeryMultiplier.convertToMontgomeryForm(point.y); if (point.z !== null) { montgomeryMultiplier.convertToMontgomeryForm(point.z) } if (typeof point.ta !== "undefined") { montgomeryMultiplier.convertToMontgomeryForm(point.ta); montgomeryMultiplier.convertToMontgomeryForm(point.tb) } } point.isInMontgomeryForm = true } function convertToStandardForm(point) { if (!point.isInMontgomeryForm) { throw new Error("The given point is not in montgomery form.") } if (!point.isInfinity) { montgomeryMultiplier.convertToStandardForm(point.x); montgomeryMultiplier.convertToStandardForm(point.y); if (point.z !== null) { montgomeryMultiplier.convertToStandardForm(point.z) } if (typeof point.ta !== "undefined") { montgomeryMultiplier.convertToStandardForm(point.ta); montgomeryMultiplier.convertToStandardForm(point.tb) } } point.isInMontgomeryForm = false } function convertToAffineForm(point) { if (point.isInfinity) { point.z = null; setterSupport || (point.isAffine = true); return } cryptoMath.modInv(point.z, curve.p, conversionTemp2, true); if (point.isInMontgomeryForm) { montgomeryMultiply(conversionTemp2, montgomeryMultiplier.rCubedModm, conversionTemp1); var swap = conversionTemp2; conversionTemp2 = conversionTemp1; conversionTemp1 = swap } montgomerySquare(conversionTemp2, conversionTemp0); montgomeryMultiply(point.x, conversionTemp0, conversionTemp1); for (var i = 0; i < fieldElementWidth; i += 1){ point.x[i] = conversionTemp1[i] } montgomeryMultiply(point.y, conversionTemp0, conversionTemp1); montgomeryMultiply(conversionTemp1, conversionTemp2, point.y); point.z = null; delete point.ta; delete point.tb; setterSupport || (point.isAffine = true) } function convertToJacobianForm(point) { if (!point.isAffine) { throw new Error("The given point is not in Affine form.") } setterSupport || (point.isAffine = false); var clonedDigits, i, zOne = point.isInMontgomeryForm ? onemontgomery : one; clonedDigits = createArray(zOne.length); for (i = 0; i < zOne.length; i += 1){ clonedDigits[i] = zOne[i] } point.z = clonedDigits; return } function validatePoint(point) { if (point.isInfinity) { return false } cryptoMath.modMul(point.y, point.y, point.curve.p, temp1); cryptoMath.modMul(point.x, point.x, point.curve.p, temp2); cryptoMath.modMul(point.x, temp2, point.curve.p, temp3); modAdd(temp3, point.curve.b, temp2); cryptoMath.modMul(point.x, point.curve.a, point.curve.p, temp3); modAdd(temp2, temp3, temp2); modSub(temp1, temp2, temp1); if (cryptoMath.isZero(temp1) === false) { return false } return true } function validatePointTed(point) { if (point.ta) { point = point.clone(); normalizeTed(point) } cryptoMath.modMul(point.y, point.y, point.curve.p, temp3); cryptoMath.modMul(point.x, point.x, point.curve.p, temp2); cryptoMath.add(temp2, temp3, temp1); cryptoMath.reduce(temp4, point.curve.p, temp4); cryptoMath.modMul(temp2, temp3, point.curve.p, temp4); cryptoMath.modMul(point.curve.d, temp4, point.curve.p, temp3); cryptoMath.add(temp3, [1], temp2); cryptoMath.reduce(temp2, point.curve.p, temp2); cryptoMath.subtract(temp1, temp2, temp1); if (cryptoMath.isZero(temp1) === false) { cryptoMath.reduce(temp1, point.curve.p, temp1); if (cryptoMath.isZero(temp1) === false) { return false } } return true } function generatePrecomputationTableTed(npoints, point) { var Q = point.clone(), P2 = Q.clone(), T = []; T[0] = convert_R1_to_R2(point); doubleTed(Q, Q); P2 = convert_R1_to_R2(Q); Q = point.clone(); for (var i = 1; i < npoints; i++){ addTedExtended(P2, Q, Q); T[i] = convert_R1_to_R2(Q) } return T } function convertToExtendedProjective(affinePoint) { affinePoint.ta = affinePoint.x.slice(); affinePoint.tb = affinePoint.y.slice(); affinePoint.z = [1] } function scalarMultiplyTed(k, point, outputPoint, multiplyBy4) { if (!validatePointTed(point)) { throw new Error("Invalid Parameter") } var rbits = point.curve.rbits; multiplyBy4 = typeof multiplyBy4 === "undefined" ? true : multiplyBy4; var w = fieldElementWidth <= 8 ? 5 : 6; var t = Math.floor((rbits + (w - 2)) / (w - 1)); var i, j; k = k.slice(); var T = point.clone(); convertToExtendedProjective(T); if (multiplyBy4) { doubleTed(T, T); doubleTed(T, T) } var precomputationTable = generatePrecomputationTableTed(1 << w - 2, T); var odd = k[0] & 1, tempk = []; modSub(point.curve.order, k, tempk); for (i = 0; i < k.length; i++){ k[i] = odd - 1 & (k[i] ^ tempk[i]) ^ k[i] } var kDigits = cryptoMath.fixedWindowRecode(k, w, t); var position = Math.floor(Math.abs(kDigits[t]) - 1) / 2; var R = precomputationTable[position]; T.x = R.x.slice(); T.y = R.y.slice(); T.z = R.z.slice(); for (i = t - 1; i >= 0; i--){ for (j = 0; j < w - 1; j++){ doubleTed(T, T) } position = Math.floor((Math.abs(kDigits[i]) - 1) / 2); var L = tableLookupTed(precomputationTable, position); var mask = -(kDigits[i] >>> 31); modSub(point.curve.p, L.x, tempk); for (var m = 0; m < L.x.length; m++){ L.x[m] = L.x[m] & ~mask | tempk[m] & mask } modSub(point.curve.p, L.td, tempk); for (m = 0; m < L.td.length; m++){ L.td[m] = L.td[m] & ~mask | tempk[m] & mask } addTedExtended(L, T, T) } modSub(point.curve.p, T.x, tempk); for (i = 0; i < T.x.length; i++){ T.x[i] = odd - 1 & (T.x[i] ^ tempk[i]) ^ T.x[i] } normalizeTed(T); outputPoint.x = T.x.slice(); outputPoint.y = T.y.slice(); return } function tableLookupTed(table, index) { var pos = (index + 1) % table.length; for (var i = 0; i < table.length; i++){ var L = { x: table[pos].x.slice(), y: table[pos].y.slice(), z: table[pos].z.slice(), td: table[pos].td.slice() }; pos = (pos + 1) % table.length } return L } function normalizeTed(point) { cryptoMath.modInv(point.z, curve.p, conversionTemp2, true); cryptoMath.modMul(point.x, conversionTemp2, curve.p, point.x); cryptoMath.modMul(point.y, conversionTemp2, curve.p, point.y); delete point.ta; delete point.tb; point.z = null; return } function doubleTed(point, outputPoint) { if (typeof point.ta === "undefined") { throw new Error("Point should be in Extended Projective form.") } cryptoMath.modMul(point.x, point.x, point.curve.p, temp0); cryptoMath.modMul(point.y, point.y, point.curve.p, temp1); cryptoMath.modMul(point.z, point.z, point.curve.p, point.ta); modSub(temp1, temp0, outputPoint.tb); modAdd(temp0, temp1, temp0); modAdd(point.ta, point.ta, point.ta); modAdd(point.y, point.y, point.y); modSub(point.ta, temp0, temp1); cryptoMath.modMul(point.x, point.y, point.curve.p, outputPoint.ta); cryptoMath.modMul(temp0, outputPoint.tb, point.curve.p, outputPoint.y); cryptoMath.modMul(temp1, outputPoint.ta, point.curve.p, outputPoint.x); cryptoMath.modMul(temp0, temp1, point.curve.p, outputPoint.z); return } function addTed(point1, point2, outputPoint) { if (typeof point1.ta === "undefined") { throw new Error("Point1 should be in Extended Projective form.") } if (typeof point2.ta === "undefined") { throw new Error("Point2 should be in Extended Projective form.") } var qq = convert_R1_to_R2(point1); addTedExtended(qq, point2, outputPoint); return } function convert_R1_to_R2(point) { var curve = point.curve, modulus = curve.p, qq = { x: point.x.slice(), y: point.y.slice(), z: point.z.slice(), td: [], curve: point.curve }; cryptoMath.modMul(point.ta, point.tb, modulus, conversionTemp0); cryptoMath.modMul(conversionTemp0, curve.d, modulus, qq.td); return qq } function addTedExtended(qq, point2, outputPoint) { var cm = cryptoMath; var modulus = point2.curve.p; temp1 = []; temp2 = []; temp3 = []; cm.modMul(point2.z, qq.z, modulus, temp3); cm.modMul(point2.ta, point2.tb, modulus, temp1); modAdd(point2.x, point2.y, point2.ta); cm.modMul(temp1, qq.td, modulus, temp2); modAdd(qq.x, qq.y, point2.tb); modSub(temp3, temp2, temp1); modAdd(temp3, temp2, temp3); cm.modMul(point2.ta, point2.tb, modulus, temp2); cm.modMul(point2.x, qq.x, modulus, point2.z); cm.modMul(point2.y, qq.y, modulus, point2.x); modSub(temp2, point2.z, temp2); modSub(point2.x, point2.z, outputPoint.ta); modSub(temp2, point2.x, outputPoint.tb); cm.modMul(outputPoint.ta, temp3, modulus, outputPoint.y); cm.modMul(outputPoint.tb, temp1, modulus, outputPoint.x); cm.modMul(temp3, temp1, modulus, outputPoint.z); return } function convertTedToWeierstrass(tedPoint, wPoint) { var a = tedPoint.curve.a.slice(), d = tedPoint.curve.d.slice(), p = tedPoint.curve.p, modMul = cryptoMath.modMul, modInv = cryptoMath.modInv; temp1 = [5]; modMul(a, temp1, p, temp2); modSub(temp2, d, temp2); modMul(d, temp1, p, temp3); modSub(a, temp3, temp1); modMul(tedPoint.y, temp1, p, temp3); modAdd(temp3, temp2, temp2); temp1 = [1]; modSub(temp1, tedPoint.y, temp3); temp1 = [12]; modMul(temp1, temp3, p, temp4); modInv(temp4, p, temp4, true); modMul(tedPoint.x, temp3, p, temp1); modAdd(temp1, temp1, temp3); modAdd(temp3, temp3, temp3); modInv(temp3, p, temp3, true); modMul(temp4, temp2, p, wPoint.x); temp1 = [1]; modAdd(tedPoint.y, temp1, temp1); modSub(a, d, temp2); modMul(temp1, temp2, p, temp4); modMul(temp4, temp3, p, wPoint.y); return } function convertWeierstrassToTed(wPoint, tedPoint) { var a = tedPoint.curve.a.slice(), d = tedPoint.curve.d.slice(), p = tedPoint.curve.p, modMul = cryptoMath.modMul, modInv = cryptoMath.modInv; modAdd(wPoint.x, wPoint.x, temp1); modAdd(wPoint.x, temp1, temp1); modAdd(temp1, temp1, temp1); modSub(temp1, a, temp2); modSub(temp2, d, temp2); modAdd(wPoint.y, wPoint.y, temp3); modAdd(wPoint.y, temp3, temp3); modAdd(temp3, temp3, temp3); modInv(temp3, p, temp3, true); modMul(temp2, temp3, p, tedPoint.x); modAdd(temp1, temp1, temp1); modAdd(temp1, d, temp2); modAdd(temp1, a, temp1); modAdd(a, a, temp3); modSub(temp2, temp3, temp2); modSub(temp2, temp3, temp2); modSub(temp2, a, temp2); modAdd(d, d, temp3); modSub(temp1, temp3, temp1); modSub(temp1, temp3, temp1); modSub(temp1, d, temp1); modInv(temp1, p, temp1, true); modMul(temp1, temp2, p, tedPoint.y); return } var methods = { convertToMontgomeryForm: convertToMontgomeryForm, convertToStandardForm: convertToStandardForm, convertToAffineForm: convertToAffineForm, convertToJacobianForm: convertToJacobianForm, generatePrecomputationTable: function (w, generatorPoint) { return generatePrecomputationTable(w, generatorPoint) } }; if (tedCurve) { methods.double = doubleTed; methods.add = addTed; methods.scalarMultiply = scalarMultiply; methods.normalize = normalizeTed; methods.convertToExtendedProjective = convertToExtendedProjective; methods.convertTedToWeierstrass = convertTedToWeierstrass; methods.convertWeierstrassToTed = convertWeierstrassToTed; methods.validatePoint = validatePointTed; methods.generatePrecomputationTable = function (w, generatorPoint) { return generatePrecomputationTableTed(w, generatorPoint) } } else { methods.double = double; methods.mixedDoubleAdd = mixedDoubleAdd; methods.mixedAdd = mixedAdd; methods.scalarMultiply = scalarMultiply; methods.negate = negate; methods.validatePoint = validatePoint } return methods }; var sec1EncodingFp = function () { return { encodePoint: function (point) { if (!point) { throw new Error("point") } if (!point.isAffine) { throw new Error("Point must be in affine form.") } if (point.isInMontgomeryForm) { throw new Error("Point must not be in Montgomery form.") } if (point.isInfinity) { return createArray(1) } else { var xOctetString = cryptoMath.digitsToBytes(point.x); var yOctetString = cryptoMath.digitsToBytes(point.y); var pOctetString = cryptoMath.digitsToBytes(point.curve.p); var mlen = pOctetString.length; if (mlen < xOctetString.length || mlen < yOctetString.length) { throw new Error("Point coordinate(s) are bigger than the field order.") } var output = createArray(2 * mlen + 1); output[0] = 4; var offset = mlen - xOctetString.length; for (var i = 0; i < xOctetString.length; i++){ output[i + 1 + offset] = xOctetString[i] } offset = mlen - yOctetString.length; for (i = 0; i < yOctetString.length; i++){ output[mlen + i + 1 + offset] = yOctetString[i] } return output } }, decodePoint: function (encoded, curve) { if (encoded.length < 1) { throw new Error("Byte array must have non-zero length") } var pOctetString = cryptoMath.digitsToBytes(curve.p); var mlen = pOctetString.length; if (encoded[0] === 0 && encoded.length === 1) { return curve.createPointAtInfinity() } else if (encoded[0] === 4 && encoded.length === 1 + 2 * mlen) { var xbytes = createArray(mlen); var ybytes = createArray(mlen); for (var i = 0; i < mlen; i++){ xbytes[i] = encoded[i + 1]; ybytes[i] = encoded[mlen + i + 1] } var x = cryptoMath.bytesToDigits(xbytes); var y = cryptoMath.bytesToDigits(ybytes); return EllipticCurvePointFp(curve, false, x, y) } else { throw new Error("Unsupported encoding format") } } } }; var ModularSquareRootSolver = function (modulus) { var p = modulus; var specialK = []; if (typeof modulus === "undefined") { throw new Error("modulus") } if (cryptoMath.isEven(modulus)) { throw new Error("Only odd moduli are supported") } var mul = cryptoMath.MontgomeryMultiplier(p); if (p[0] % 4 === 3) { cryptoMath.add(p, cryptoMath.One, specialK); cryptoMath.shiftRight(specialK, specialK, 2) } else { specialK = null } var temp0 = new Array(p.length); var temp1 = new Array(p.length); function squareRootNistCurves(a) { var beta = cryptoMath.intToDigits(0, 16); mul.modExp(a, specialK, beta); var aPrime = [0]; cryptoMath.modMul(beta, beta, mul.m, aPrime); if (cryptoMath.compareDigits(a, aPrime) !== 0) { return null } return beta } var publicMethods = { squareRoot: function (a) { if (specialK !== null) { return squareRootNistCurves(a) } else { throw new Error("GeneralCase not supported.") } }, jacobiSymbol: function (a) { var modEightMask = 7, modFourMask = 3, aPrime, pPrime; aPrime = a.slice(); pPrime = p.slice(); cryptoMath.reduce(aPrime, pPrime, aPrime, temp0, temp1); var t = 1; while (!cryptoMath.isZero(aPrime)) { while (cryptoMath.isEven(aPrime)) { cryptoMath.shiftRight(aPrime, aPrime); var pMod8 = pPrime[0] & modEightMask; if (pMod8 === 3 || pMod8 === 5) { t = -t } } var tmp = aPrime; aPrime = pPrime; pPrime = tmp; var aMod4 = aPrime[0] & modFourMask; var pMod4 = pPrime[0] & modFourMask; if (aMod4 === 3 && pMod4 === 3) { t = -t } cryptoMath.reduce(aPrime, pPrime, aPrime, temp0, temp1) } if (cryptoMath.compareDigits(pPrime, cryptoMath.One) === 0) { return t } else { return 0 } } }; return publicMethods }; var curvesInternal = {}; var createCurve = function (curveName) { var curveData = curvesInternal[curveName.toUpperCase()]; if (!curveData) { throw new Error(curveName + " Unsupported curve.") } if (curveData.type === 0) { return createWeierstrassCurve(curveData) } if (curveData.type === 1) { return createTedCurve(curveData) } throw new Error(curveName + " Unsupported curve type.") }; var validateEccPoint = function (curveName, x, y, z) { var curve = createCurve(curveName); var point = new EllipticCurvePointFp(curve, false, btd(x), btd(y), z && btd(z), false); var opp = new EllipticCurveOperatorFp(curve); return opp.validatePoint(point) }; return { createCurve: createCurve, curves: curvesInternal, sec1EncodingFp: sec1EncodingFp, validatePoint: validateEccPoint, EllipticCurvePointFp: EllipticCurvePointFp, EllipticCurveOperatorFp: EllipticCurveOperatorFp, ModularSquareRootSolver: ModularSquareRootSolver } } var cryptoECC = cryptoECC || MsrcryptoECC(); { module.exports = cryptoECC } })(cryptoECC$1); var curve_P256 = { name: "P-256", type: 0, p: [255, 255, 255, 255, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], a: [255, 255, 255, 255, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 252], b: [90, 198, 53, 216, 170, 58, 147, 231, 179, 235, 189, 85, 118, 152, 134, 188, 101, 29, 6, 176, 204, 83, 176, 246, 59, 206, 60, 62, 39, 210, 96, 75], order: [255, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 188, 230, 250, 173, 167, 23, 158, 132, 243, 185, 202, 194, 252, 99, 37, 81], gx: [107, 23, 209, 242, 225, 44, 66, 71, 248, 188, 230, 229, 99, 164, 64, 242, 119, 3, 125, 129, 45, 235, 51, 160, 244, 161, 57, 69, 216, 152, 194, 150], gy: [79, 227, 66, 226, 254, 26, 127, 155, 142, 231, 235, 74, 124, 15, 158, 22, 43, 206, 51, 87, 107, 49, 94, 206, 203, 182, 64, 104, 55, 191, 81, 245], cf: 1 }; var curve_P384 = { name: "P-384", type: 0, p: [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255], a: [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 252], b: [179, 49, 47, 167, 226, 62, 231, 228, 152, 142, 5, 107, 227, 248, 45, 25, 24, 29, 156, 110, 254, 129, 65, 18, 3, 20, 8, 143, 80, 19, 135, 90, 198, 86, 57, 141, 138, 46, 209, 157, 42, 133, 200, 237, 211, 236, 42, 239], order: [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 199, 99, 77, 129, 244, 55, 45, 223, 88, 26, 13, 178, 72, 176, 167, 122, 236, 236, 25, 106, 204, 197, 41, 115], gx: [170, 135, 202, 34, 190, 139, 5, 55, 142, 177, 199, 30, 243, 32, 173, 116, 110, 29, 59, 98, 139, 167, 155, 152, 89, 247, 65, 224, 130, 84, 42, 56, 85, 2, 242, 93, 191, 85, 41, 108, 58, 84, 94, 56, 114, 118, 10, 183], gy: [54, 23, 222, 74, 150, 38, 44, 111, 93, 158, 152, 191, 146, 146, 220, 41, 248, 244, 29, 189, 40, 154, 20, 124, 233, 218, 49, 19, 181, 240, 184, 192, 10, 96, 177, 206, 29, 126, 129, 157, 122, 67, 29, 124, 144, 234, 14, 95], cf: 1 }; var curve_P521 = { name: "P-521", type: 0, p: [1, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], a: [1, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 252], b: [0, 81, 149, 62, 185, 97, 142, 28, 154, 31, 146, 154, 33, 160, 182, 133, 64, 238, 162, 218, 114, 91, 153, 179, 21, 243, 184, 180, 137, 145, 142, 241, 9, 225, 86, 25, 57, 81, 236, 126, 147, 123, 22, 82, 192, 189, 59, 177, 191, 7, 53, 115, 223, 136, 61, 44, 52, 241, 239, 69, 31, 212, 107, 80, 63, 0], order: [1, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 250, 81, 134, 135, 131, 191, 47, 150, 107, 127, 204, 1, 72, 247, 9, 165, 208, 59, 181, 201, 184, 137, 156, 71, 174, 187, 111, 183, 30, 145, 56, 100, 9], gx: [0, 198, 133, 142, 6, 183, 4, 4, 233, 205, 158, 62, 203, 102, 35, 149, 180, 66, 156, 100, 129, 57, 5, 63, 181, 33, 248, 40, 175, 96, 107, 77, 61, 186, 161, 75, 94, 119, 239, 231, 89, 40, 254, 29, 193, 39, 162, 255, 168, 222, 51, 72, 179, 193, 133, 106, 66, 155, 249, 126, 126, 49, 194, 229, 189, 102], gy: [1, 24, 57, 41, 106, 120, 154, 59, 192, 4, 92, 138, 95, 180, 44, 125, 27, 217, 152, 245, 68, 73, 87, 155, 68, 104, 23, 175, 189, 23, 39, 62, 102, 44, 151, 238, 114, 153, 94, 244, 38, 64, 197, 80, 185, 1, 63, 173, 7, 97, 53, 60, 112, 134, 162, 114, 194, 64, 136, 190, 148, 118, 159, 209, 102, 80], cf: 1 }; var cryptoECC = typeof commonjsRequire === "function" ? cryptoECCExports : cryptoECC; if (typeof cryptoECC !== "undefined") { cryptoECC.curves["P-256"] = curve_P256; cryptoECC.curves["P-384"] = curve_P384; cryptoECC.curves["P-521"] = curve_P521 } class P256ECGroupParams{ constructor() { this.descGq = ECGroup.P256; this.Gq = new Group(this.descGq); this.oid = "1.3.6.1.4.1.311.75.1.2.2"; this.g = [this.Gq.parsePoint([241, 185, 134, 213, 209, 31, 67, 72, 58, 231, 54, 232, 134, 175, 117, 14, 135, 13, 127, 12, 35, 18, 170, 216, 219, 92, 138, 62, 52, 245, 57, 30], [100, 52, 123, 127, 73, 49, 135, 165, 59, 55, 8, 148, 184, 248, 227, 143, 210, 44, 185, 147, 2, 57, 61, 121, 220, 226, 37, 145, 142, 186, 97, 238]), this.Gq.parsePoint([21, 84, 207, 152, 62, 11, 6, 12, 120, 112, 94, 215, 209, 74, 73, 65, 176, 46, 96, 140, 219, 120, 246, 167, 90, 82, 52, 89, 120, 20, 31, 211], [98, 84, 14, 105, 12, 143, 169, 254, 16, 126, 33, 65, 223, 198, 144, 127, 116, 245, 254, 235, 223, 91, 18, 215, 21, 59, 70, 53, 162, 223, 106, 118]), this.Gq.parsePoint([50, 121, 26, 119, 158, 154, 164, 117, 186, 38, 102, 160, 228, 122, 146, 139, 33, 171, 25, 5, 250, 175, 72, 187, 128, 98, 186, 233, 0, 158, 178, 125], [24, 116, 186, 134, 234, 25, 79, 177, 77, 204, 233, 250, 34, 54, 111, 71, 53, 202, 234, 33, 25, 190, 182, 63, 43, 174, 193, 154, 158, 147, 165, 69]), this.Gq.parsePoint([192, 239, 173, 181, 195, 1, 94, 66, 193, 215, 26, 195, 144, 196, 210, 42, 111, 93, 85, 47, 99, 187, 204, 89, 25, 10, 234, 106, 238, 22, 53, 74], [83, 240, 19, 62, 164, 77, 162, 12, 80, 154, 78, 91, 233, 176, 39, 219, 225, 62, 58, 96, 67, 157, 190, 114, 8, 75, 12, 117, 160, 73, 114, 63]), this.Gq.parsePoint([189, 95, 41, 223, 102, 64, 73, 63, 249, 108, 108, 188, 73, 203, 142, 95, 97, 70, 39, 146, 219, 117, 242, 14, 244, 155, 248, 110, 38, 13, 201, 85], [32, 76, 68, 14, 248, 198, 235, 43, 236, 12, 52, 58, 206, 156, 109, 100, 225, 136, 200, 180, 240, 97, 61, 100, 132, 106, 219, 220, 61, 143, 223, 173]), this.Gq.parsePoint([217, 26, 189, 162, 110, 197, 195, 0, 28, 241, 202, 44, 9, 173, 136, 102, 37, 88, 66, 109, 195, 180, 209, 181, 1, 231, 171, 194, 219, 8, 12, 220], [84, 235, 177, 127, 237, 133, 90, 54, 193, 247, 74, 184, 37, 98, 8, 232, 99, 7, 169, 242, 183, 86, 215, 200, 75, 79, 185, 72, 94, 15, 245, 245]), this.Gq.parsePoint([134, 235, 44, 148, 226, 182, 214, 32, 163, 145, 180, 8, 13, 254, 43, 55, 124, 194, 13, 152, 27, 91, 192, 204, 169, 78, 134, 86, 151, 149, 158, 190], [38, 172, 21, 137, 197, 40, 128, 195, 184, 248, 29, 43, 243, 41, 118, 99, 96, 25, 241, 109, 142, 250, 31, 77, 32, 149, 11, 153, 8, 206, 183, 225]), this.Gq.parsePoint([85, 83, 20, 142, 68, 37, 38, 146, 217, 231, 234, 156, 24, 148, 105, 221, 44, 14, 139, 212, 73, 64, 91, 111, 59, 31, 39, 146, 69, 179, 127, 13], [121, 12, 164, 206, 144, 224, 72, 167, 66, 91, 102, 42, 99, 22, 18, 208, 34, 79, 32, 142, 75, 230, 233, 7, 195, 231, 217, 96, 122, 153, 127, 109]), this.Gq.parsePoint([119, 102, 141, 151, 191, 247, 213, 218, 105, 93, 109, 114, 228, 248, 64, 32, 93, 226, 137, 206, 143, 241, 233, 149, 36, 53, 176, 180, 221, 78, 34, 46], [20, 118, 6, 11, 51, 254, 99, 107, 185, 183, 95, 16, 120, 93, 75, 67, 25, 5, 205, 0, 111, 131, 43, 247, 49, 3, 185, 248, 128, 55, 133, 86]), this.Gq.parsePoint([114, 154, 114, 190, 131, 117, 136, 143, 103, 223, 150, 210, 165, 46, 27, 56, 74, 241, 198, 143, 248, 183, 60, 173, 246, 41, 108, 114, 194, 193, 250, 178], [1, 49, 32, 230, 148, 45, 7, 64, 162, 95, 139, 135, 30, 31, 47, 233, 168, 96, 73, 119, 209, 218, 161, 138, 240, 228, 254, 213, 112, 198, 234, 46]), this.Gq.parsePoint([207, 186, 1, 78, 242, 115, 75, 176, 213, 24, 99, 161, 230, 174, 142, 180, 174, 24, 159, 140, 25, 67, 42, 244, 109, 159, 22, 253, 212, 63, 188, 24], [18, 86, 199, 132, 248, 39, 195, 26, 210, 61, 141, 35, 54, 120, 206, 46, 235, 206, 52, 70, 41, 231, 165, 247, 166, 217, 74, 220, 15, 244, 122, 126]), this.Gq.parsePoint([108, 20, 7, 196, 154, 81, 246, 118, 37, 235, 139, 41, 149, 172, 17, 148, 66, 136, 153, 91, 58, 129, 120, 154, 94, 179, 230, 191, 79, 45, 237, 120], [22, 216, 114, 73, 79, 193, 141, 119, 64, 79, 144, 110, 88, 144, 33, 80, 225, 252, 221, 160, 207, 33, 21, 22, 246, 241, 148, 21, 232, 137, 47, 38]), this.Gq.parsePoint([217, 35, 28, 49, 91, 175, 114, 36, 105, 247, 79, 186, 85, 186, 102, 23, 119, 233, 28, 166, 50, 10, 136, 37, 189, 161, 203, 240, 234, 32, 96, 146], [54, 228, 205, 18, 136, 8, 141, 236, 238, 168, 231, 182, 210, 44, 253, 151, 185, 159, 135, 250, 204, 149, 241, 137, 31, 198, 162, 139, 216, 30, 95, 80]), this.Gq.parsePoint([53, 53, 135, 17, 56, 65, 6, 184, 98, 162, 207, 11, 64, 62, 128, 85, 146, 12, 117, 152, 191, 180, 153, 135, 168, 156, 53, 105, 229, 160, 91, 97], [24, 237, 250, 29, 252, 101, 58, 5, 116, 202, 136, 253, 170, 236, 223, 233, 235, 117, 48, 154, 172, 190, 146, 108, 33, 16, 233, 38, 120, 200, 78, 61]), this.Gq.parsePoint([37, 208, 92, 38, 23, 114, 22, 108, 8, 72, 61, 0, 0, 63, 68, 53, 32, 233, 19, 36, 203, 233, 24, 252, 52, 0, 138, 147, 39, 22, 215, 235], [102, 138, 19, 197, 209, 99, 246, 100, 107, 242, 232, 244, 45, 31, 72, 231, 154, 158, 173, 2, 9, 34, 179, 131, 0, 107, 103, 109, 41, 211, 90, 66]), this.Gq.parsePoint([252, 3, 92, 133, 170, 14, 156, 82, 126, 167, 220, 162, 106, 45, 183, 77, 194, 80, 232, 165, 171, 232, 83, 187, 222, 209, 89, 89, 215, 35, 15, 67], [101, 240, 82, 163, 130, 178, 199, 140, 170, 159, 207, 201, 82, 9, 111, 76, 204, 71, 114, 84, 110, 87, 152, 100, 145, 35, 254, 249, 78, 201, 90, 204]), this.Gq.parsePoint([133, 179, 135, 63, 217, 17, 191, 6, 169, 120, 250, 64, 226, 97, 225, 200, 86, 246, 56, 202, 158, 200, 203, 232, 130, 106, 96, 130, 200, 69, 45, 15], [60, 240, 13, 105, 88, 111, 86, 190, 216, 73, 213, 233, 226, 130, 90, 0, 60, 229, 98, 170, 181, 248, 27, 215, 24, 164, 233, 65, 152, 158, 17, 1]), this.Gq.parsePoint([69, 73, 248, 198, 33, 234, 186, 87, 237, 35, 54, 213, 25, 32, 246, 252, 77, 195, 78, 4, 125, 177, 52, 198, 25, 128, 228, 227, 88, 197, 227, 36], [57, 232, 190, 35, 240, 64, 51, 160, 248, 188, 67, 213, 161, 27, 30, 121, 141, 37, 181, 199, 93, 116, 14, 253, 48, 153, 133, 237, 197, 222, 219, 152]), this.Gq.parsePoint([184, 173, 56, 107, 84, 249, 118, 110, 92, 177, 162, 240, 80, 203, 202, 42, 34, 97, 155, 160, 8, 253, 249, 73, 109, 243, 138, 108, 234, 120, 78, 178], [91, 51, 58, 12, 222, 157, 220, 141, 101, 113, 177, 202, 196, 86, 164, 113, 68, 201, 193, 110, 206, 134, 106, 83, 132, 148, 234, 15, 234, 238, 240, 172]), this.Gq.parsePoint([86, 98, 140, 125, 99, 102, 225, 196, 169, 54, 30, 95, 126, 73, 65, 92, 128, 253, 161, 76, 4, 241, 6, 240, 99, 142, 200, 207, 89, 170, 4, 133], [116, 253, 194, 96, 128, 43, 109, 245, 90, 100, 2, 51, 136, 149, 53, 205, 4, 224, 223, 132, 182, 109, 157, 164, 100, 93, 163, 17, 147, 153, 80, 70]), this.Gq.parsePoint([143, 31, 90, 14, 52, 46, 101, 87, 185, 85, 53, 84, 56, 96, 141, 176, 158, 77, 35, 126, 199, 35, 14, 44, 131, 107, 213, 243, 233, 28, 108, 18], [44, 26, 33, 2, 166, 158, 247, 74, 0, 99, 83, 194, 210, 209, 221, 157, 189, 250, 176, 7, 253, 8, 231, 200, 142, 184, 105, 160, 166, 105, 177]), this.Gq.parsePoint([190, 175, 119, 87, 163, 206, 67, 220, 141, 74, 7, 50, 225, 227, 24, 244, 151, 85, 230, 30, 95, 87, 168, 91, 236, 207, 33, 183, 220, 200, 24, 226], [64, 210, 108, 42, 220, 63, 65, 208, 145, 86, 2, 90, 157, 195, 79, 211, 202, 107, 150, 128, 157, 61, 124, 245, 242, 141, 0, 161, 237, 189, 105, 149]), this.Gq.parsePoint([229, 19, 195, 229, 14, 250, 68, 54, 25, 156, 90, 81, 253, 105, 30, 164, 220, 171, 188, 32, 42, 128, 41, 186, 61, 240, 51, 111, 18, 216, 38, 99], [117, 244, 47, 88, 72, 13, 44, 173, 86, 155, 15, 19, 203, 243, 118, 195, 145, 50, 113, 217, 247, 132, 66, 66, 184, 112, 81, 157, 43, 232, 57, 142]), this.Gq.parsePoint([180, 43, 59, 5, 188, 175, 187, 114, 128, 14, 226, 66, 171, 76, 183, 171, 215, 127, 31, 206, 172, 124, 225, 211, 39, 238, 194, 91, 61, 230, 196, 61], [114, 95, 91, 61, 12, 221, 27, 134, 189, 122, 139, 214, 53, 193, 172, 237, 186, 201, 29, 108, 53, 22, 62, 174, 102, 129, 7, 81, 244, 212, 98, 136]), this.Gq.parsePoint([200, 164, 167, 223, 107, 239, 108, 97, 239, 80, 191, 253, 156, 250, 126, 253, 226, 37, 48, 240, 178, 208, 55, 30, 129, 155, 128, 232, 133, 213, 146, 221], [25, 110, 126, 10, 129, 208, 59, 56, 168, 249, 145, 4, 129, 47, 100, 120, 75, 98, 212, 25, 145, 245, 102, 222, 39, 132, 123, 107, 185, 186, 162, 81]), this.Gq.parsePoint([162, 42, 244, 94, 90, 122, 154, 159, 148, 145, 14, 140, 219, 94, 100, 158, 131, 195, 143, 193, 54, 159, 28, 169, 250, 29, 81, 136, 124, 56, 221, 241], [117, 155, 211, 140, 110, 9, 254, 44, 215, 91, 79, 53, 95, 68, 32, 226, 231, 178, 223, 217, 247, 20, 122, 160, 61, 83, 115, 179, 97, 43, 131, 137]), this.Gq.parsePoint([34, 244, 122, 106, 174, 193, 66, 53, 148, 129, 238, 164, 144, 152, 136, 43, 62, 202, 196, 98, 91, 29, 37, 98, 176, 39, 24, 72, 118, 44, 93, 222], [62, 11, 126, 12, 81, 160, 99, 48, 53, 128, 202, 37, 227, 38, 174, 126, 97, 8, 110, 166, 228, 196, 149, 210, 81, 98, 134, 112, 57, 217, 254, 76]), this.Gq.parsePoint([234, 226, 78, 156, 191, 74, 142, 185, 44, 28, 200, 13, 117, 220, 244, 76, 57, 223, 228, 237, 207, 19, 195, 229, 228, 183, 186, 8, 195, 41, 55, 141], [47, 127, 255, 250, 67, 162, 208, 38, 140, 37, 228, 240, 134, 99, 254, 242, 108, 87, 150, 47, 213, 246, 35, 41, 47, 6, 30, 161, 156, 87, 16, 161]), this.Gq.parsePoint([173, 146, 176, 152, 82, 138, 226, 8, 87, 36, 116, 227, 202, 43, 31, 111, 190, 19, 60, 180, 250, 181, 238, 186, 14, 70, 16, 12, 104, 77, 91, 188], [71, 151, 134, 133, 250, 143, 65, 202, 82, 70, 189, 99, 71, 186, 101, 246, 112, 236, 101, 161, 54, 22, 108, 117, 231, 147, 99, 70, 225, 106, 215, 144]), this.Gq.parsePoint([220, 90, 188, 157, 158, 42, 4, 167, 186, 56, 52, 110, 130, 113, 25, 245, 15, 163, 17, 184, 203, 75, 18, 207, 83, 96, 47, 52, 130, 166, 9, 192], [233, 79, 115, 213, 217, 100, 25, 66, 24, 143, 208, 255, 100, 167, 117, 16, 33, 250, 246, 204, 156, 77, 42, 160, 49, 142, 148, 240, 89, 120, 190]), this.Gq.parsePoint([93, 0, 139, 155, 222, 187, 56, 36, 147, 91, 220, 104, 167, 172, 66, 108, 85, 64, 88, 169, 220, 78, 216, 190, 162, 234, 116, 169, 45, 244, 127, 195], [24, 5, 213, 248, 240, 151, 234, 139, 59, 134, 8, 220, 95, 1, 111, 217, 9, 120, 27, 117, 144, 13, 83, 206, 139, 101, 132, 101, 24, 202, 11, 218]), this.Gq.parsePoint([75, 255, 22, 6, 126, 55, 121, 143, 243, 227, 36, 43, 17, 190, 57, 248, 61, 215, 69, 30, 190, 17, 1, 234, 196, 136, 122, 111, 147, 213, 2, 6], [6, 94, 94, 49, 225, 80, 19, 96, 54, 225, 146, 37, 73, 185, 253, 154, 133, 89, 151, 18, 159, 69, 102, 211, 245, 172, 248, 161, 228, 208, 172, 131]), this.Gq.parsePoint([174, 203, 167, 240, 116, 81, 35, 217, 198, 166, 14, 155, 212, 97, 168, 99, 97, 49, 176, 149, 245, 150, 23, 132, 157, 51, 93, 42, 125, 139, 24, 123], [95, 98, 213, 234, 244, 169, 168, 146, 72, 140, 13, 233, 93, 141, 133, 237, 169, 3, 91, 101, 151, 234, 38, 116, 215, 167, 238, 125, 74, 83, 94, 189]), this.Gq.parsePoint([167, 78, 203, 128, 115, 36, 150, 232, 246, 206, 114, 244, 85, 105, 55, 194, 55, 225, 158, 250, 199, 86, 124, 21, 31, 56, 107, 101, 6, 86, 162, 38], [4, 246, 97, 65, 83, 19, 40, 77, 144, 68, 133, 230, 246, 219, 143, 233, 71, 130, 178, 186, 36, 192, 203, 166, 202, 119, 85, 126, 252, 216, 240, 94]), this.Gq.parsePoint([237, 14, 150, 86, 105, 1, 122, 167, 31, 52, 46, 200, 160, 153, 187, 240, 26, 11, 158, 171, 148, 246, 38, 35, 236, 249, 107, 204, 14, 20, 228, 171], [36, 75, 241, 37, 82, 62, 242, 151, 141, 176, 96, 6, 205, 167, 207, 62, 77, 88, 57, 119, 17, 217, 40, 151, 96, 61, 186, 226, 155, 130, 134, 75]), this.Gq.parsePoint([6, 155, 132, 59, 219, 240, 23, 212, 22, 167, 103, 209, 52, 225, 194, 212, 151, 250, 210, 205, 170, 227, 107, 39, 83, 112, 255, 81, 42, 52, 191, 167], [61, 59, 227, 210, 232, 110, 176, 122, 135, 132, 155, 46, 241, 110, 227, 3, 16, 184, 110, 99, 179, 71, 129, 99, 253, 6, 182, 89, 43, 189, 229, 69]), this.Gq.parsePoint([89, 45, 72, 21, 138, 99, 88, 162, 144, 13, 69, 61, 121, 232, 141, 107, 194, 11, 127, 168, 203, 43, 252, 252, 223, 208, 130, 150, 5, 37, 173, 131], [114, 49, 195, 209, 248, 111, 204, 27, 108, 158, 140, 22, 174, 69, 169, 53, 8, 201, 196, 158, 138, 116, 94, 100, 176, 118, 54, 252, 107, 3, 16, 63]), this.Gq.parsePoint([24, 255, 172, 117, 7, 184, 240, 34, 235, 169, 114, 42, 234, 147, 198, 202, 116, 112, 130, 90, 120, 124, 31, 152, 43, 8, 61, 218, 4, 144, 237, 50], [48, 75, 131, 96, 74, 148, 255, 138, 39, 135, 176, 71, 232, 35, 229, 10, 100, 237, 202, 11, 29, 204, 185, 56, 17, 150, 89, 122, 28, 99, 179, 98]), this.Gq.parsePoint([221, 229, 223, 194, 134, 122, 97, 186, 46, 4, 109, 213, 37, 118, 211, 211, 58, 36, 23, 62, 50, 215, 22, 202, 240, 214, 188, 75, 209, 25, 67, 116], [121, 182, 227, 11, 24, 34, 214, 30, 173, 229, 155, 10, 179, 237, 190, 143, 66, 145, 200, 224, 129, 221, 206, 222, 255, 0, 188, 50, 235, 252, 26, 147]), this.Gq.parsePoint([224, 247, 42, 140, 113, 57, 94, 25, 6, 59, 14, 9, 249, 71, 248, 108, 6, 244, 179, 0, 200, 29, 59, 187, 196, 141, 203, 33, 154, 185, 96, 170], [111, 35, 30, 10, 83, 140, 143, 84, 192, 102, 201, 62, 26, 248, 87, 188, 59, 28, 65, 136, 2, 39, 76, 189, 245, 227, 135, 216, 135, 54, 245, 118]), this.Gq.parsePoint([56, 83, 136, 7, 142, 162, 180, 121, 45, 172, 143, 190, 11, 71, 72, 185, 152, 0, 202, 8, 102, 98, 250, 142, 171, 214, 37, 150, 221, 126, 92, 83], [77, 33, 18, 17, 29, 91, 244, 123, 174, 209, 196, 162, 104, 140, 250, 97, 110, 123, 187, 100, 212, 18, 241, 107, 55, 18, 136, 191, 233, 87, 234, 97]), this.Gq.parsePoint([177, 8, 170, 62, 139, 241, 247, 7, 246, 186, 149, 86, 170, 15, 24, 113, 81, 151, 52, 166, 152, 32, 63, 117, 50, 146, 84, 67, 178, 2, 12, 189], [90, 117, 250, 231, 173, 11, 226, 53, 32, 115, 71, 121, 239, 17, 243, 37, 221, 231, 166, 237, 198, 51, 54, 239, 159, 181, 134, 97, 252, 204, 70, 165]), this.Gq.parsePoint([6, 5, 179, 80, 95, 119, 231, 75, 34, 234, 126, 103, 195, 51, 63, 243, 183, 183, 113, 115, 131, 137, 211, 5, 170, 89, 77, 143, 85, 2, 55, 219], [116, 135, 173, 178, 224, 124, 58, 185, 46, 19, 134, 84, 103, 144, 160, 17, 73, 126, 185, 251, 152, 70, 113, 107, 4, 121, 61, 206, 164, 48, 199, 171]), this.Gq.parsePoint([216, 24, 131, 169, 207, 29, 195, 4, 60, 68, 249, 240, 249, 255, 80, 44, 208, 69, 228, 41, 76, 55, 90, 48, 168, 166, 90, 188, 13, 210, 130, 100], [29, 117, 201, 158, 180, 78, 45, 139, 67, 165, 63, 105, 182, 136, 31, 150, 146, 148, 53, 226, 179, 133, 10, 55, 1, 174, 208, 38, 232, 10, 50, 145]), this.Gq.parsePoint([147, 236, 144, 135, 156, 210, 216, 106, 34, 118, 244, 75, 66, 223, 115, 98, 131, 210, 151, 71, 7, 89, 222, 10, 242, 198, 201, 47, 22, 132, 130, 175], [31, 69, 244, 128, 160, 236, 118, 7, 81, 102, 121, 194, 187, 159, 103, 122, 137, 212, 80, 236, 70, 154, 201, 48, 161, 13, 33, 60, 30, 178, 169, 207]), this.Gq.parsePoint([78, 158, 158, 184, 226, 103, 192, 214, 23, 96, 236, 171, 201, 172, 25, 221, 172, 93, 185, 92, 40, 51, 78, 201, 157, 73, 215, 77, 64, 182, 109, 175], [93, 215, 28, 146, 211, 17, 236, 21, 213, 226, 230, 211, 184, 213, 19, 54, 65, 90, 96, 142, 20, 4, 140, 134, 206, 236, 118, 78, 109, 230, 223, 73]), this.Gq.parsePoint([206, 180, 202, 152, 246, 32, 25, 89, 107, 155, 198, 35, 78, 165, 194, 2, 153, 144, 240, 141, 6, 143, 39, 238, 244, 250, 125, 152, 151, 191, 175, 98], [65, 96, 251, 221, 175, 41, 134, 243, 161, 30, 41, 181, 137, 185, 217, 29, 139, 21, 197, 248, 187, 240, 47, 127, 23, 95, 110, 248, 231, 194, 177, 164]), this.Gq.parsePoint([128, 232, 112, 103, 9, 189, 37, 168, 73, 55, 65, 126, 45, 106, 109, 175, 168, 61, 55, 56, 223, 180, 47, 142, 239, 160, 251, 82, 71, 214, 153, 133], [106, 143, 46, 166, 178, 48, 30, 58, 239, 189, 130, 70, 246, 235, 151, 234, 12, 225, 21, 92, 224, 183, 44, 71, 29, 1, 176, 208, 184, 141, 162, 202]), this.Gq.parsePoint([19, 189, 38, 6, 6, 103, 248, 235, 126, 86, 231, 130, 133, 74, 243, 179, 224, 16, 207, 24, 37, 166, 132, 188, 114, 178, 135, 234, 123, 44, 35, 76], [24, 113, 193, 90, 166, 248, 204, 58, 218, 45, 75, 246, 187, 43, 198, 41, 108, 166, 88, 124, 18, 45, 243, 180, 122, 159, 170, 48, 37, 134, 58, 140]), this.Gq.parsePoint([125, 94, 105, 186, 206, 146, 14, 142, 210, 208, 180, 58, 209, 72, 73, 215, 30, 38, 114, 156, 179, 127, 0, 154, 225, 78, 109, 138, 6, 94, 144, 121], [19, 214, 200, 214, 174, 2, 115, 161, 137, 1, 41, 119, 159, 206, 52, 240, 202, 246, 243, 83, 191, 222, 158, 227, 55, 39, 134, 120, 201, 182, 231, 88])]; this.gt = this.Gq.parsePoint([226, 171, 129, 222, 245, 147, 233, 153, 201, 117, 168, 164, 134, 104, 185, 160, 126, 85, 148, 207, 214, 143, 172, 41, 241, 122, 129, 28, 178, 107, 62, 16], [117, 99, 17, 248, 150, 197, 3, 236, 219, 47, 96, 138, 28, 203, 250, 55, 138, 149, 235, 69, 120, 230, 95, 25, 15, 26, 139, 84, 77, 32, 176, 130]) } } class P384ECGroupParams{ constructor() { this.descGq = ECGroup.P384; this.Gq = new Group(this.descGq); this.oid = "1.3.6.1.4.1.311.75.1.2.2"; this.g = [this.Gq.parsePoint([74, 174, 87, 157, 213, 109, 120, 9, 11, 153, 33, 243, 27, 247, 41, 240, 116, 18, 26, 58, 223, 250, 45, 49, 208, 18, 21, 190, 238, 29, 196, 223, 157, 244, 99, 253, 94, 43, 143, 108, 107, 10, 66, 22, 37, 138, 200, 68], [60, 59, 138, 35, 197, 214, 106, 162, 240, 150, 69, 33, 25, 10, 146, 129, 69, 30, 154, 227, 172, 228, 183, 55, 110, 2, 215, 179, 148, 158, 34, 116, 232, 68, 140, 173, 239, 126, 81, 153, 23, 32, 180, 154, 69, 176, 88, 5]), this.Gq.parsePoint([3, 47, 8, 110, 172, 123, 235, 85, 160, 201, 94, 90, 217, 150, 227, 157, 222, 116, 179, 182, 109, 251, 194, 184, 241, 37, 41, 217, 223, 74, 44, 184, 74, 165, 76, 230, 154, 177, 251, 34, 205, 127, 215, 153, 103, 210, 97, 194], [22, 187, 240, 120, 101, 78, 57, 22, 128, 189, 181, 116, 149, 1, 140, 200, 254, 5, 19, 10, 191, 218, 168, 74, 180, 175, 144, 208, 210, 214, 192, 31, 253, 168, 188, 150, 207, 203, 0, 22, 243, 219, 19, 216, 10, 232, 162, 208]), this.Gq.parsePoint([214, 88, 58, 254, 72, 49, 27, 236, 92, 144, 22, 104, 37, 49, 201, 53, 207, 63, 169, 142, 51, 213, 3, 53, 72, 32, 201, 159, 178, 233, 2, 234, 205, 180, 25, 68, 18, 3, 226, 135, 176, 211, 58, 219, 190, 145, 46, 51], [127, 158, 53, 192, 192, 218, 242, 230, 142, 209, 53, 235, 192, 121, 113, 213, 142, 14, 106, 200, 218, 105, 245, 79, 12, 9, 62, 36, 221, 63, 98, 117, 30, 129, 107, 111, 110, 31, 203, 102, 34, 108, 79, 11, 53, 249, 172, 220]), this.Gq.parsePoint([62, 248, 81, 182, 224, 168, 78, 36, 252, 153, 155, 5, 60, 246, 172, 243, 42, 220, 148, 23, 132, 174, 240, 222, 20, 130, 62, 247, 171, 190, 126, 126, 73, 231, 216, 12, 211, 82, 149, 234, 223, 51, 34, 101, 212, 218, 22, 95], [24, 40, 153, 211, 70, 82, 98, 108, 116, 116, 152, 147, 102, 177, 241, 122, 212, 217, 200, 18, 134, 58, 103, 188, 223, 125, 133, 192, 237, 89, 203, 115, 32, 102, 62, 187, 143, 255, 61, 95, 86, 50, 224, 167, 94, 0, 153, 102]), this.Gq.parsePoint([11, 131, 68, 3, 26, 149, 138, 55, 77, 232, 238, 7, 17, 193, 85, 84, 64, 75, 254, 220, 168, 14, 72, 137, 146, 43, 219, 12, 235, 173, 58, 48, 201, 34, 245, 73, 45, 44, 228, 136, 75, 161, 199, 123, 87, 47, 160, 189], [13, 125, 112, 124, 236, 46, 203, 206, 215, 111, 50, 212, 60, 231, 181, 92, 189, 83, 39, 63, 85, 96, 91, 123, 155, 172, 139, 63, 82, 27, 177, 83, 150, 134, 150, 123, 225, 139, 90, 164, 26, 113, 101, 247, 38, 171, 93, 187]), this.Gq.parsePoint([216, 101, 25, 130, 241, 207, 171, 38, 114, 112, 33, 154, 238, 37, 7, 54, 213, 53, 194, 137, 163, 140, 136, 93, 242, 142, 235, 246, 15, 118, 58, 18, 161, 102, 32, 172, 197, 149, 105, 115, 8, 238, 209, 219, 5, 172, 212, 240], [47, 196, 58, 17, 184, 40, 200, 84, 106, 184, 193, 198, 174, 180, 26, 104, 87, 196, 129, 89, 4, 23, 182, 89, 172, 139, 211, 238, 83, 199, 15, 211, 247, 170, 19, 240, 101, 112, 22, 136, 35, 175, 252, 232, 74, 94, 134, 29]), this.Gq.parsePoint([228, 43, 193, 118, 225, 59, 222, 207, 43, 49, 96, 24, 162, 44, 249, 81, 2, 183, 26, 31, 168, 172, 28, 254, 20, 238, 197, 76, 173, 37, 106, 154, 185, 180, 167, 168, 239, 60, 253, 227, 56, 79, 228, 161, 188, 17, 194, 244], [78, 38, 0, 39, 53, 201, 38, 151, 135, 112, 87, 37, 96, 56, 231, 147, 76, 29, 66, 129, 38, 244, 30, 119, 27, 25, 8, 64, 219, 172, 15, 89, 189, 94, 7, 2, 37, 34, 182, 56, 162, 147, 62, 20, 99, 57, 220, 198]), this.Gq.parsePoint([215, 20, 16, 179, 227, 162, 34, 170, 251, 127, 83, 237, 76, 216, 41, 158, 68, 39, 49, 32, 59, 236, 246, 67, 239, 129, 218, 55, 29, 129, 66, 25, 28, 242, 90, 39, 1, 149, 135, 41, 77, 35, 135, 12, 120, 252, 160, 73], [93, 201, 128, 10, 208, 237, 160, 51, 171, 225, 52, 221, 216, 148, 242, 150, 181, 174, 189, 68, 88, 238, 66, 84, 206, 112, 248, 77, 251, 13, 225, 143, 202, 153, 191, 121, 92, 167, 226, 8, 24, 46, 246, 196, 109, 123, 212, 148]), this.Gq.parsePoint([104, 135, 43, 22, 74, 110, 155, 143, 153, 102, 139, 91, 253, 74, 192, 119, 13, 234, 100, 227, 119, 50, 163, 132, 188, 57, 195, 36, 132, 184, 96, 145, 205, 71, 221, 234, 229, 38, 177, 128, 101, 232, 102, 62, 30, 203, 139, 128], [102, 96, 138, 167, 207, 10, 181, 60, 55, 80, 52, 221, 227, 151, 54, 220, 129, 214, 131, 27, 198, 238, 120, 199, 20, 224, 16, 175, 165, 200, 84, 37, 167, 237, 40, 239, 111, 70, 42, 235, 77, 121, 82, 234, 244, 136, 208, 193]), this.Gq.parsePoint([160, 77, 236, 199, 233, 240, 207, 136, 147, 10, 178, 108, 150, 214, 149, 35, 118, 180, 195, 163, 219, 117, 37, 110, 253, 212, 102, 245, 31, 124, 1, 132, 26, 95, 78, 106, 159, 17, 135, 127, 242, 134, 203, 199, 67, 6, 187, 241], [24, 200, 9, 40, 172, 32, 130, 192, 79, 48, 13, 49, 178, 230, 208, 14, 230, 135, 114, 94, 184, 111, 13, 199, 199, 168, 251, 149, 153, 60, 234, 202, 138, 252, 228, 128, 237, 199, 39, 132, 46, 254, 209, 72, 136, 45, 186, 166]), this.Gq.parsePoint([233, 128, 44, 229, 54, 29, 215, 158, 177, 79, 0, 77, 30, 42, 125, 171, 76, 165, 88, 98, 185, 55, 89, 60, 134, 3, 95, 206, 13, 58, 73, 193, 161, 52, 126, 157, 137, 233, 52, 139, 248, 70, 15, 230, 70, 104, 170, 231], [41, 153, 41, 0, 129, 27, 18, 196, 46, 253, 225, 35, 207, 101, 184, 11, 178, 73, 228, 142, 63, 83, 228, 71, 117, 203, 27, 54, 83, 110, 40, 107, 35, 224, 141, 76, 89, 245, 13, 221, 137, 185, 219, 78, 1, 42, 79, 20]), this.Gq.parsePoint([133, 55, 178, 154, 139, 96, 198, 115, 148, 211, 3, 120, 219, 89, 15, 199, 4, 255, 54, 58, 108, 121, 1, 238, 41, 187, 139, 24, 63, 220, 139, 10, 234, 213, 244, 56, 228, 67, 132, 212, 30, 213, 242, 107, 230, 164, 199, 231], [117, 195, 190, 41, 94, 56, 129, 59, 39, 34, 188, 252, 186, 212, 145, 198, 43, 216, 26, 20, 56, 134, 77, 143, 84, 164, 138, 67, 138, 106, 85, 108, 92, 198, 189, 149, 73, 194, 92, 231, 227, 157, 152, 97, 163, 11, 110, 8]), this.Gq.parsePoint([228, 107, 232, 255, 177, 166, 18, 119, 87, 75, 77, 78, 117, 32, 187, 40, 223, 26, 169, 43, 117, 57, 11, 246, 170, 129, 152, 132, 164, 125, 182, 126, 10, 90, 63, 117, 76, 239, 109, 197, 125, 7, 37, 199, 150, 128, 109, 133], [30, 12, 251, 197, 9, 37, 130, 247, 2, 0, 47, 172, 133, 221, 47, 50, 239, 86, 142, 0, 152, 1, 195, 215, 150, 17, 170, 58, 160, 238, 191, 45, 85, 145, 1, 20, 69, 18, 251, 44, 26, 89, 127, 63, 11, 5, 245, 67]), this.Gq.parsePoint([246, 214, 223, 60, 134, 123, 136, 106, 75, 211, 119, 86, 5, 110, 114, 0, 157, 46, 38, 76, 178, 93, 221, 89, 192, 184, 61, 77, 14, 64, 20, 79, 100, 159, 67, 87, 212, 22, 161, 119, 47, 122, 30, 78, 43, 221, 171, 21], [6, 217, 181, 14, 132, 130, 70, 243, 16, 185, 47, 1, 131, 93, 83, 219, 238, 142, 39, 248, 131, 170, 109, 37, 73, 229, 39, 254, 120, 8, 169, 203, 97, 146, 49, 117, 168, 238, 205, 51, 40, 87, 74, 62, 215, 187, 89, 186]), this.Gq.parsePoint([56, 138, 108, 181, 92, 93, 8, 188, 234, 216, 33, 28, 253, 32, 227, 44, 120, 235, 111, 6, 215, 146, 16, 26, 0, 192, 215, 87, 72, 0, 70, 249, 196, 170, 93, 248, 130, 23, 107, 188, 141, 131, 31, 114, 129, 74, 121, 12], [66, 123, 137, 133, 24, 47, 144, 54, 1, 157, 40, 50, 86, 25, 185, 202, 148, 66, 117, 8, 43, 210, 253, 25, 133, 0, 193, 124, 155, 184, 174, 125, 89, 30, 253, 100, 225, 128, 112, 196, 207, 49, 100, 224, 146, 109, 253, 205]), this.Gq.parsePoint([243, 15, 190, 236, 145, 41, 113, 219, 170, 213, 237, 99, 59, 91, 42, 55, 106, 230, 14, 39, 134, 175, 22, 150, 149, 175, 0, 246, 218, 155, 188, 253, 154, 67, 86, 64, 151, 201, 2, 37, 197, 78, 42, 99, 185, 192, 0, 79], [49, 254, 181, 144, 60, 181, 103, 159, 233, 104, 111, 23, 48, 62, 139, 207, 131, 53, 250, 7, 246, 253, 224, 107, 112, 98, 226, 211, 55, 247, 44, 122, 161, 173, 238, 95, 191, 92, 179, 116, 40, 68, 240, 126, 2, 253, 71, 109]), this.Gq.parsePoint([188, 86, 24, 126, 98, 179, 163, 194, 70, 223, 1, 216, 248, 133, 195, 77, 84, 255, 129, 66, 74, 189, 29, 34, 123, 3, 63, 6, 236, 206, 198, 39, 141, 192, 117, 154, 22, 217, 15, 12, 197, 22, 22, 197, 14, 154, 136, 69], [58, 83, 44, 215, 77, 31, 115, 220, 2, 190, 253, 139, 0, 45, 179, 98, 235, 19, 59, 61, 156, 206, 197, 69, 41, 241, 93, 115, 2, 218, 29, 139, 76, 123, 54, 101, 78, 79, 141, 42, 62, 77, 165, 235, 155, 41, 167, 226]), this.Gq.parsePoint([137, 151, 114, 18, 111, 152, 56, 236, 23, 137, 97, 80, 124, 174, 216, 37, 139, 111, 16, 47, 90, 119, 8, 186, 191, 128, 221, 29, 204, 220, 112, 2, 30, 79, 65, 194, 247, 67, 139, 235, 103, 201, 162, 169, 180, 213, 127, 132], [113, 185, 166, 253, 185, 30, 189, 10, 41, 43, 219, 113, 131, 119, 48, 142, 222, 218, 6, 61, 7, 203, 3, 78, 27, 200, 110, 162, 246, 95, 162, 15, 9, 53, 198, 200, 195, 120, 202, 238, 254, 100, 221, 187, 58, 220, 121, 237]), this.Gq.parsePoint([203, 46, 191, 128, 127, 30, 111, 228, 17, 223, 104, 152, 205, 246, 82, 203, 185, 189, 223, 57, 71, 53, 80, 17, 66, 157, 17, 27, 178, 97, 141, 196, 109, 239, 202, 70, 154, 9, 193, 151, 72, 207, 29, 9, 170, 130, 25, 190], [80, 35, 138, 139, 39, 7, 205, 184, 140, 56, 29, 87, 54, 155, 77, 120, 56, 215, 137, 88, 118, 249, 163, 216, 10, 149, 86, 165, 199, 151, 164, 208, 219, 131, 153, 252, 214, 87, 173, 209, 147, 139, 101, 199, 175, 173, 138, 114]), this.Gq.parsePoint([149, 250, 121, 90, 164, 244, 192, 218, 72, 100, 32, 250, 148, 27, 37, 215, 247, 12, 128, 115, 183, 139, 205, 136, 32, 216, 20, 102, 137, 216, 30, 29, 194, 164, 9, 142, 134, 175, 194, 123, 73, 200, 106, 239, 237, 27, 13, 97], [98, 61, 55, 193, 61, 203, 110, 169, 87, 51, 114, 136, 138, 240, 139, 234, 207, 148, 200, 223, 252, 44, 182, 21, 3, 10, 230, 18, 176, 207, 20, 120, 117, 29, 195, 181, 106, 102, 165, 29, 180, 185, 142, 38, 78, 176, 22, 221]), this.Gq.parsePoint([34, 244, 51, 2, 13, 193, 41, 199, 190, 116, 85, 142, 249, 194, 145, 243, 147, 142, 120, 23, 180, 125, 75, 65, 165, 146, 33, 216, 91, 16, 255, 209, 184, 21, 145, 159, 179, 113, 126, 62, 126, 21, 233, 63, 185, 127, 111, 124], [20, 69, 76, 174, 14, 236, 203, 204, 142, 82, 21, 85, 253, 46, 200, 34, 194, 144, 196, 100, 103, 30, 167, 170, 153, 213, 88, 144, 159, 220, 204, 246, 142, 77, 112, 149, 196, 100, 122, 22, 228, 127, 22, 192, 182, 136, 81, 193]), this.Gq.parsePoint([69, 105, 130, 178, 53, 217, 208, 19, 201, 155, 100, 9, 77, 65, 41, 99, 31, 177, 198, 33, 6, 40, 80, 92, 116, 65, 51, 230, 250, 23, 93, 20, 31, 180, 192, 1, 5, 248, 16, 40, 76, 104, 128, 180, 106, 68, 6, 223], [82, 184, 73, 130, 86, 81, 106, 79, 239, 222, 19, 181, 167, 187, 215, 45, 63, 25, 170, 0, 179, 98, 109, 236, 221, 156, 209, 255, 125, 23, 92, 247, 68, 226, 36, 22, 243, 81, 246, 46, 93, 1, 190, 101, 28, 168, 39, 71]), this.Gq.parsePoint([69, 31, 119, 203, 207, 34, 190, 230, 164, 7, 40, 126, 249, 163, 111, 41, 63, 168, 34, 243, 149, 246, 76, 46, 220, 203, 154, 181, 248, 238, 63, 222, 134, 239, 221, 207, 51, 2, 232, 233, 41, 55, 50, 160, 88, 51, 40, 22], [119, 52, 1, 161, 15, 229, 6, 157, 188, 198, 135, 12, 235, 139, 21, 209, 203, 53, 34, 123, 216, 175, 125, 112, 182, 61, 54, 233, 86, 19, 222, 186, 45, 96, 3, 131, 80, 39, 73, 60, 4, 99, 14, 219, 39, 0, 185, 101]), this.Gq.parsePoint([164, 173, 80, 183, 219, 207, 205, 196, 39, 231, 47, 133, 10, 27, 176, 64, 40, 28, 95, 153, 185, 20, 21, 28, 71, 172, 72, 249, 251, 123, 133, 160, 88, 88, 243, 3, 88, 140, 87, 210, 255, 102, 181, 134, 113, 69, 251, 219], [10, 86, 67, 54, 181, 227, 122, 172, 57, 186, 160, 135, 140, 108, 80, 211, 211, 111, 84, 9, 241, 2, 249, 184, 104, 115, 40, 9, 69, 98, 202, 98, 136, 178, 182, 159, 238, 67, 137, 26, 213, 97, 211, 46, 212, 187, 32, 248]), this.Gq.parsePoint([241, 180, 241, 50, 179, 194, 154, 158, 52, 103, 160, 34, 8, 23, 242, 88, 120, 67, 231, 117, 67, 232, 18, 236, 82, 77, 125, 65, 60, 108, 32, 192, 62, 195, 155, 85, 131, 98, 32, 113, 125, 221, 154, 244, 42, 255, 230, 103], [52, 71, 161, 52, 45, 64, 168, 192, 148, 6, 3, 69, 16, 46, 100, 177, 179, 135, 27, 128, 239, 40, 211, 39, 112, 248, 73, 181, 126, 118, 150, 17, 143, 89, 107, 139, 17, 155, 171, 221, 45, 124, 207, 39, 181, 90, 205, 23]), this.Gq.parsePoint([9, 112, 39, 156, 88, 20, 125, 212, 13, 42, 175, 235, 206, 62, 11, 193, 62, 228, 221, 187, 116, 105, 9, 204, 226, 132, 155, 237, 152, 216, 183, 179, 110, 217, 113, 161, 122, 142, 117, 205, 181, 243, 235, 220, 62, 113, 180, 123], [44, 193, 122, 205, 160, 150, 181, 99, 147, 222, 99, 198, 107, 35, 66, 160, 62, 46, 80, 79, 18, 57, 128, 1, 184, 217, 15, 225, 88, 29, 38, 150, 191, 134, 67, 70, 88, 84, 224, 217, 173, 233, 238, 33, 69, 243, 192, 47]), this.Gq.parsePoint([43, 94, 23, 194, 25, 228, 234, 149, 175, 57, 178, 74, 32, 220, 77, 80, 134, 112, 126, 216, 6, 107, 210, 152, 227, 4, 125, 100, 89, 130, 63, 241, 2, 239, 97, 125, 70, 112, 213, 158, 14, 251, 150, 94, 23, 155, 1, 166], [36, 32, 35, 86, 124, 103, 11, 207, 33, 201, 194, 239, 105, 187, 139, 135, 215, 168, 220, 208, 52, 182, 102, 6, 144, 8, 18, 57, 62, 233, 152, 155, 195, 126, 37, 171, 103, 42, 62, 164, 239, 59, 2, 143, 131, 73, 86, 35]), this.Gq.parsePoint([129, 254, 102, 220, 142, 124, 88, 62, 209, 82, 68, 181, 215, 236, 134, 151, 37, 188, 53, 52, 111, 243, 6, 62, 106, 34, 72, 62, 146, 214, 112, 139, 89, 143, 65, 228, 38, 29, 76, 82, 200, 31, 215, 3, 133, 60, 11, 93], [35, 247, 90, 148, 229, 248, 100, 133, 6, 151, 97, 156, 171, 184, 179, 78, 255, 86, 159, 41, 216, 130, 117, 183, 167, 174, 29, 119, 128, 158, 58, 90, 66, 92, 130, 181, 189, 184, 215, 170, 117, 249, 92, 83, 163, 124, 249, 96]), this.Gq.parsePoint([70, 228, 212, 188, 98, 129, 212, 148, 62, 11, 92, 234, 216, 110, 184, 245, 130, 27, 255, 212, 40, 136, 181, 121, 219, 113, 113, 200, 36, 22, 188, 248, 99, 24, 125, 134, 129, 85, 180, 160, 174, 31, 62, 68, 207, 113, 7, 175], [20, 100, 36, 108, 84, 202, 58, 139, 112, 218, 61, 169, 63, 253, 136, 102, 51, 110, 122, 186, 218, 80, 157, 57, 39, 109, 8, 90, 156, 157, 213, 92, 4, 255, 222, 240, 197, 236, 6, 152, 58, 171, 14, 99, 252, 17, 134, 253]), this.Gq.parsePoint([227, 211, 39, 55, 113, 68, 164, 6, 255, 45, 34, 251, 38, 202, 99, 77, 106, 138, 14, 228, 187, 57, 170, 208, 179, 94, 102, 54, 172, 204, 202, 242, 10, 202, 120, 252, 26, 2, 204, 96, 72, 5, 51, 48, 52, 7, 142, 248], [71, 236, 152, 211, 24, 248, 113, 203, 111, 228, 145, 191, 218, 242, 97, 216, 98, 172, 146, 234, 93, 38, 155, 148, 24, 117, 230, 54, 220, 92, 226, 204, 116, 102, 144, 138, 96, 175, 71, 154, 162, 199, 15, 148, 186, 10, 211, 3]), this.Gq.parsePoint([189, 66, 84, 151, 33, 158, 43, 202, 59, 71, 98, 155, 25, 247, 157, 77, 203, 39, 98, 132, 180, 92, 63, 90, 201, 180, 123, 118, 185, 14, 206, 146, 53, 101, 92, 249, 87, 247, 122, 218, 144, 45, 209, 117, 228, 148, 218, 145], [41, 128, 224, 200, 212, 74, 50, 52, 82, 17, 85, 75, 241, 183, 172, 30, 222, 240, 197, 204, 26, 96, 212, 42, 212, 225, 158, 155, 154, 170, 228, 207, 31, 188, 169, 235, 1, 225, 50, 223, 102, 248, 152, 87, 185, 48, 48, 8]), this.Gq.parsePoint([42, 108, 87, 109, 242, 175, 123, 20, 5, 218, 173, 233, 251, 36, 187, 254, 179, 250, 156, 85, 134, 3, 96, 136, 224, 125, 157, 189, 49, 85, 233, 169, 105, 34, 174, 225, 133, 247, 49, 87, 156, 125, 140, 209, 167, 163, 68, 228], [68, 145, 111, 229, 218, 7, 229, 173, 254, 241, 131, 125, 93, 63, 194, 174, 221, 213, 176, 91, 156, 217, 212, 7, 21, 254, 164, 66, 17, 72, 109, 130, 206, 149, 162, 114, 150, 181, 171, 58, 144, 31, 99, 213, 1, 242, 177, 247]), this.Gq.parsePoint([231, 229, 180, 44, 114, 47, 180, 123, 217, 44, 165, 129, 192, 90, 160, 15, 28, 24, 192, 255, 101, 73, 57, 241, 156, 204, 182, 237, 60, 77, 249, 247, 176, 160, 59, 180, 149, 196, 76, 187, 188, 233, 63, 72, 149, 136, 38, 55], [48, 146, 227, 42, 243, 156, 64, 194, 75, 90, 17, 16, 11, 232, 16, 50, 159, 5, 1, 111, 121, 47, 175, 80, 135, 111, 119, 244, 245, 97, 241, 135, 102, 176, 29, 164, 79, 178, 229, 78, 132, 148, 111, 42, 60, 150, 112, 176]), this.Gq.parsePoint([166, 149, 154, 104, 166, 218, 122, 70, 141, 14, 239, 130, 116, 146, 211, 136, 138, 242, 129, 29, 6, 39, 193, 138, 169, 9, 221, 10, 228, 176, 32, 209, 51, 228, 139, 145, 27, 55, 126, 5, 204, 183, 127, 238, 234, 50, 102, 115], [112, 237, 235, 70, 124, 24, 209, 89, 71, 72, 36, 223, 190, 89, 66, 155, 79, 173, 201, 124, 254, 63, 132, 152, 99, 7, 180, 186, 80, 250, 242, 196, 182, 13, 115, 242, 179, 149, 181, 149, 187, 110, 205, 217, 106, 79, 227, 233]), this.Gq.parsePoint([153, 56, 18, 124, 88, 239, 158, 254, 105, 204, 67, 173, 117, 139, 58, 242, 59, 255, 222, 132, 247, 24, 47, 9, 0, 149, 225, 24, 131, 75, 103, 8, 126, 231, 6, 180, 100, 64, 50, 56, 137, 37, 58, 34, 62, 207, 200, 101], [55, 241, 201, 66, 79, 8, 96, 227, 236, 226, 248, 16, 120, 0, 246, 216, 108, 144, 154, 159, 68, 103, 156, 53, 87, 236, 235, 75, 88, 20, 180, 179, 150, 188, 142, 154, 154, 120, 187, 234, 183, 193, 49, 63, 10, 75, 227, 24]), this.Gq.parsePoint([96, 234, 225, 105, 225, 56, 223, 73, 121, 222, 213, 9, 186, 206, 237, 3, 230, 52, 73, 16, 211, 97, 53, 234, 102, 83, 239, 245, 92, 7, 108, 251, 84, 193, 238, 155, 192, 181, 232, 18, 156, 146, 159, 218, 100, 62, 130, 217], [101, 33, 2, 18, 202, 133, 33, 160, 249, 2, 32, 99, 195, 216, 22, 52, 161, 180, 100, 155, 2, 101, 25, 135, 252, 226, 168, 94, 63, 174, 166, 3, 91, 191, 162, 94, 77, 228, 118, 149, 215, 239, 11, 231, 198, 85, 41, 244]), this.Gq.parsePoint([171, 9, 176, 72, 91, 215, 234, 226, 75, 248, 42, 202, 244, 140, 179, 132, 138, 132, 31, 227, 130, 108, 162, 191, 217, 29, 42, 254, 223, 190, 239, 7, 169, 29, 29, 53, 183, 196, 34, 68, 83, 21, 215, 70, 102, 162, 220, 91], [107, 233, 16, 41, 254, 217, 1, 50, 152, 46, 52, 245, 129, 184, 92, 186, 141, 105, 144, 98, 183, 101, 120, 128, 134, 147, 241, 52, 242, 3, 250, 134, 106, 31, 178, 250, 252, 135, 119, 41, 43, 181, 198, 44, 19, 10, 148, 16]), this.Gq.parsePoint([235, 202, 154, 2, 72, 45, 116, 85, 208, 230, 175, 73, 46, 97, 30, 252, 144, 140, 31, 184, 81, 181, 143, 51, 27, 42, 176, 135, 162, 217, 182, 72, 243, 15, 63, 101, 83, 63, 76, 85, 9, 117, 190, 185, 22, 139, 8, 73], [104, 93, 247, 178, 194, 117, 122, 91, 91, 169, 61, 145, 40, 99, 136, 246, 87, 184, 155, 209, 46, 54, 200, 222, 156, 149, 129, 138, 164, 253, 53, 123, 76, 20, 223, 114, 162, 188, 65, 54, 253, 148, 118, 22, 10, 175, 101, 28]), this.Gq.parsePoint([218, 183, 159, 234, 53, 162, 136, 58, 67, 192, 40, 82, 210, 141, 200, 183, 160, 45, 95, 51, 28, 241, 165, 185, 97, 170, 43, 57, 160, 54, 117, 107, 252, 128, 245, 31, 148, 87, 20, 32, 155, 11, 232, 129, 187, 130, 193, 182], [76, 45, 6, 61, 64, 91, 69, 105, 170, 109, 201, 41, 38, 227, 251, 54, 59, 63, 236, 118, 45, 12, 111, 13, 178, 103, 7, 60, 254, 63, 120, 186, 162, 184, 203, 93, 112, 0, 188, 143, 219, 40, 31, 241, 72, 230, 38, 118]), this.Gq.parsePoint([46, 165, 146, 94, 237, 224, 105, 110, 5, 181, 117, 209, 202, 68, 102, 177, 167, 68, 144, 252, 145, 210, 18, 97, 37, 126, 6, 198, 197, 216, 217, 88, 220, 27, 52, 163, 194, 209, 70, 7, 237, 188, 21, 25, 158, 227, 110, 115], [118, 141, 185, 174, 141, 230, 169, 213, 27, 115, 37, 241, 116, 113, 237, 100, 34, 184, 151, 127, 189, 254, 254, 253, 235, 13, 94, 178, 135, 156, 245, 185, 157, 231, 160, 107, 238, 243, 93, 77, 75, 71, 30, 61, 174, 150, 174, 148]), this.Gq.parsePoint([95, 194, 113, 19, 225, 14, 180, 21, 17, 136, 6, 134, 148, 144, 86, 158, 154, 66, 212, 227, 206, 178, 39, 216, 147, 109, 206, 162, 124, 173, 177, 106, 134, 254, 108, 17, 110, 96, 117, 26, 252, 83, 84, 242, 159, 152, 36, 221], [28, 126, 137, 14, 167, 110, 202, 254, 40, 182, 84, 90, 32, 5, 181, 223, 95, 194, 57, 24, 170, 109, 76, 129, 249, 104, 16, 143, 245, 101, 251, 238, 1, 136, 45, 238, 68, 178, 63, 180, 36, 39, 216, 148, 95, 73, 246, 244]), this.Gq.parsePoint([25, 247, 54, 145, 80, 20, 193, 33, 97, 47, 240, 251, 170, 68, 121, 237, 186, 48, 132, 7, 54, 208, 15, 24, 217, 192, 140, 254, 23, 112, 174, 233, 18, 181, 22, 248, 42, 113, 241, 118, 37, 188, 16, 213, 110, 167, 85, 134], [26, 90, 49, 24, 148, 233, 13, 1, 159, 161, 84, 198, 137, 7, 6, 141, 26, 41, 7, 227, 63, 214, 131, 97, 79, 160, 44, 233, 226, 45, 76, 244, 15, 156, 183, 15, 250, 116, 56, 131, 65, 233, 6, 53, 162, 226, 96, 244]), this.Gq.parsePoint([41, 118, 55, 53, 199, 245, 107, 246, 189, 122, 27, 106, 31, 47, 135, 188, 124, 212, 133, 146, 39, 10, 244, 101, 151, 5, 49, 214, 217, 250, 154, 41, 156, 64, 115, 194, 239, 94, 211, 249, 96, 92, 125, 212, 51, 178, 8, 188], [116, 132, 255, 101, 50, 199, 251, 41, 78, 212, 119, 74, 98, 154, 162, 235, 175, 208, 43, 145, 110, 205, 145, 132, 193, 52, 199, 57, 205, 42, 89, 42, 64, 152, 76, 210, 26, 97, 200, 128, 6, 126, 239, 44, 150, 11, 35, 162]), this.Gq.parsePoint([130, 222, 208, 57, 87, 127, 78, 29, 179, 135, 34, 32, 10, 220, 157, 238, 228, 119, 200, 146, 148, 132, 50, 234, 3, 130, 243, 211, 20, 220, 203, 184, 148, 71, 24, 251, 191, 146, 195, 26, 137, 168, 193, 13, 170, 119, 138, 176], [37, 129, 2, 128, 252, 242, 128, 159, 184, 228, 110, 165, 247, 95, 156, 140, 212, 174, 62, 86, 10, 175, 181, 160, 254, 139, 206, 125, 138, 194, 129, 30, 113, 63, 223, 202, 124, 40, 20, 132, 30, 100, 173, 195, 43, 251, 102, 45]), this.Gq.parsePoint([27, 65, 80, 46, 205, 32, 129, 125, 60, 133, 231, 0, 78, 102, 150, 56, 199, 37, 209, 21, 138, 168, 3, 209, 5, 171, 191, 133, 149, 81, 133, 89, 139, 211, 22, 251, 188, 30, 157, 164, 176, 171, 70, 126, 52, 23, 45, 65], [14, 55, 8, 247, 33, 220, 105, 249, 42, 248, 17, 119, 111, 177, 226, 72, 2, 81, 178, 4, 245, 177, 205, 244, 173, 170, 237, 102, 176, 105, 139, 217, 250, 102, 98, 60, 91, 240, 86, 190, 227, 79, 140, 186, 38, 148, 74, 124]), this.Gq.parsePoint([74, 229, 118, 164, 22, 65, 172, 156, 238, 104, 215, 97, 104, 202, 45, 211, 165, 168, 161, 194, 209, 176, 56, 45, 248, 196, 191, 119, 0, 139, 227, 178, 45, 22, 191, 169, 218, 74, 90, 28, 210, 119, 163, 19, 105, 173, 4, 254], [83, 200, 206, 122, 66, 210, 184, 213, 185, 64, 149, 147, 26, 0, 91, 211, 32, 89, 57, 85, 230, 65, 185, 212, 17, 2, 248, 31, 52, 70, 94, 217, 103, 214, 153, 146, 183, 129, 14, 11, 83, 104, 225, 31, 169, 191, 75, 194]), this.Gq.parsePoint([226, 171, 135, 83, 177, 30, 195, 82, 251, 220, 49, 129, 154, 241, 147, 124, 29, 114, 45, 16, 11, 109, 138, 10, 157, 254, 175, 91, 254, 38, 31, 120, 128, 26, 11, 128, 162, 2, 140, 118, 126, 87, 144, 206, 169, 78, 202, 29], [4, 215, 199, 16, 8, 165, 13, 139, 95, 22, 157, 35, 213, 130, 22, 36, 246, 135, 157, 61, 105, 36, 33, 138, 148, 187, 248, 214, 151, 37, 119, 7, 115, 170, 135, 238, 76, 239, 1, 206, 110, 41, 67, 82, 73, 17, 127, 111]), this.Gq.parsePoint([55, 88, 139, 74, 202, 15, 197, 171, 245, 41, 4, 96, 114, 226, 51, 247, 124, 75, 99, 217, 125, 42, 51, 128, 12, 16, 98, 193, 25, 108, 83, 9, 142, 17, 246, 67, 206, 193, 197, 74, 186, 166, 169, 178, 125, 29, 235, 123], [12, 25, 206, 203, 6, 162, 220, 125, 10, 231, 108, 226, 196, 80, 24, 5, 37, 227, 221, 2, 183, 109, 128, 151, 237, 68, 11, 200, 217, 65, 5, 230, 182, 174, 87, 204, 243, 60, 144, 42, 64, 196, 95, 188, 255, 214, 6, 159]), this.Gq.parsePoint([255, 237, 178, 165, 115, 92, 110, 171, 77, 58, 38, 171, 63, 113, 106, 211, 101, 47, 31, 167, 4, 234, 76, 95, 6, 78, 9, 223, 89, 224, 100, 254, 154, 171, 137, 182, 17, 208, 82, 68, 36, 178, 236, 77, 53, 65, 53, 103], [138, 249, 19, 188, 230, 14, 132, 234, 129, 195, 215, 170, 99, 125, 64, 119, 233, 165, 204, 79, 166, 168, 1, 218, 217, 222, 166, 154, 86, 202, 206, 111, 163, 139, 137, 30, 61, 250, 7, 242, 198, 191, 164, 92, 72, 15, 66]), this.Gq.parsePoint([229, 26, 148, 241, 187, 5, 96, 82, 244, 104, 226, 242, 27, 188, 90, 210, 246, 114, 237, 63, 131, 125, 224, 137, 189, 89, 169, 199, 90, 123, 251, 151, 251, 135, 16, 63, 255, 65, 95, 177, 148, 238, 139, 87, 242, 220, 219, 37], [27, 95, 119, 14, 188, 159, 103, 65, 249, 125, 78, 130, 123, 253, 106, 204, 89, 42, 206, 8, 16, 125, 178, 111, 62, 180, 40, 238, 24, 205, 25, 126, 114, 185, 73, 230, 23, 37, 69, 223, 222, 224, 70, 69, 87, 26, 61, 199])]; this.gt = this.Gq.parsePoint([174, 20, 30, 145, 87, 138, 38, 103, 247, 183, 144, 97, 224, 160, 245, 185, 228, 89, 222, 48, 56, 198, 151, 117, 61, 47, 126, 225, 192, 138, 102, 35, 22, 218, 13, 4, 197, 210, 17, 92, 252, 190, 208, 3, 229, 27, 142, 56], [77, 77, 96, 247, 102, 81, 131, 72, 60, 139, 251, 70, 108, 54, 191, 30, 20, 131, 122, 119, 83, 160, 221, 29, 204, 3, 109, 145, 175, 83, 193, 12, 254, 118, 90, 198, 25, 8, 71, 210, 246, 104, 59, 120, 225, 224, 159, 12]) } } class P521ECGroupParams{ constructor() { this.descGq = ECGroup.P521; this.Gq = new Group(this.descGq); this.oid = "1.3.6.1.4.1.311.75.1.2.3"; this.g = [this.Gq.parsePoint([1, 103, 91, 118, 228, 242, 28, 239, 177, 31, 254, 129, 243, 19, 124, 25, 230, 153, 146, 209, 68, 3, 63, 35, 243, 147, 13, 29, 91, 1, 60, 168, 22, 152, 161, 85, 242, 41, 133, 0, 202, 238, 227, 107, 19, 206, 245, 44, 161, 196, 33, 40, 106, 229, 159, 104, 104, 76, 133, 120, 98, 139, 161, 39, 59, 101], [198, 49, 230, 10, 188, 189, 151, 1, 54, 32, 30, 90, 142, 67, 89, 248, 205, 49, 105, 204, 57, 100, 86, 185, 161, 45, 4, 49, 123, 59, 238, 154, 162, 122, 200, 253, 132, 230, 122, 97, 147, 76, 99, 209, 217, 92, 211, 248, 144, 3, 253, 181, 123, 252, 187, 113, 248, 17, 254, 181, 150, 218, 237, 126, 58]), this.Gq.parsePoint([1, 229, 101, 238, 40, 1, 243, 216, 34, 102, 71, 119, 176, 139, 67, 242, 229, 11, 96, 170, 102, 158, 175, 152, 112, 179, 127, 232, 247, 55, 115, 184, 249, 46, 190, 12, 5, 25, 244, 148, 191, 147, 141, 85, 7, 45, 190, 165, 147, 149, 3, 110, 92, 11, 166, 139, 136, 90, 210, 171, 180, 124, 100, 2, 180, 99], [114, 51, 219, 247, 70, 221, 44, 43, 246, 42, 134, 15, 54, 69, 12, 175, 41, 93, 136, 211, 149, 82, 29, 115, 86, 201, 96, 246, 85, 120, 252, 200, 44, 41, 214, 192, 102, 242, 196, 160, 245, 72, 248, 108, 193, 188, 126, 161, 46, 167, 211, 76, 226, 65, 209, 152, 249, 84, 217, 140, 79, 102, 120, 120, 189]), this.Gq.parsePoint([1, 99, 228, 31, 130, 185, 215, 86, 199, 116, 170, 132, 162, 8, 158, 125, 171, 104, 166, 68, 84, 145, 45, 144, 227, 207, 55, 249, 98, 63, 189, 124, 116, 2, 65, 127, 102, 174, 23, 81, 157, 180, 198, 198, 152, 189, 133, 61, 191, 234, 47, 211, 236, 120, 239, 232, 135, 209, 189, 136, 124, 221, 187, 160, 187, 6], [176, 129, 27, 216, 42, 202, 69, 159, 150, 156, 181, 228, 100, 46, 91, 103, 181, 45, 252, 150, 116, 226, 186, 61, 36, 236, 232, 98, 254, 121, 172, 81, 62, 246, 94, 140, 157, 63, 115, 187, 40, 200, 79, 32, 214, 180, 87, 193, 148, 20, 54, 224, 242, 128, 188, 215, 97, 35, 247, 57, 122, 243, 160, 251, 140]), this.Gq.parsePoint([27, 198, 142, 12, 204, 211, 226, 240, 98, 117, 137, 16, 98, 70, 49, 127, 183, 51, 70, 254, 185, 22, 226, 202, 97, 60, 56, 130, 84, 221, 111, 15, 98, 26, 154, 95, 86, 202, 194, 92, 53, 52, 144, 244, 50, 233, 220, 167, 110, 245, 162, 255, 177, 133, 29, 248, 146, 8, 44, 109, 88, 63, 78, 170, 49], [66, 90, 188, 33, 219, 101, 140, 183, 211, 50, 93, 116, 144, 213, 55, 37, 88, 247, 98, 0, 19, 105, 37, 11, 128, 134, 228, 212, 151, 7, 6, 235, 75, 81, 191, 118, 198, 67, 170, 87, 191, 163, 206, 95, 107, 120, 49, 232, 193, 103, 255, 41, 226, 198, 149, 139, 82, 134, 189, 228, 245, 243, 32, 235, 235]), this.Gq.parsePoint([101, 17, 11, 128, 178, 243, 186, 25, 171, 127, 90, 111, 191, 245, 99, 59, 182, 179, 20, 133, 99, 189, 26, 41, 172, 27, 185, 215, 72, 128, 13, 79, 40, 240, 77, 238, 16, 232, 143, 134, 175, 190, 171, 126, 16, 252, 207, 246, 153, 3, 211, 63, 124, 190, 246, 253, 223, 101, 21, 150, 120, 44, 215, 108, 87], [239, 169, 187, 4, 193, 218, 83, 197, 217, 167, 233, 162, 109, 51, 182, 65, 97, 60, 211, 116, 40, 71, 95, 220, 248, 33, 148, 140, 69, 114, 219, 68, 79, 153, 127, 144, 118, 129, 240, 196, 102, 45, 139, 8, 181, 45, 4, 161, 9, 33, 84, 54, 176, 163, 228, 143, 0, 150, 59, 153, 196, 144, 232, 250, 57]), this.Gq.parsePoint([1, 249, 255, 117, 254, 76, 163, 242, 182, 95, 102, 133, 162, 63, 98, 1, 237, 70, 14, 89, 213, 23, 41, 4, 5, 175, 199, 247, 151, 175, 39, 42, 6, 244, 80, 151, 23, 209, 137, 0, 92, 233, 59, 227, 50, 19, 33, 132, 237, 79, 246, 103, 151, 102, 230, 23, 38, 126, 157, 119, 1, 116, 233, 57, 139, 2], [232, 126, 188, 83, 89, 81, 186, 24, 185, 222, 255, 216, 8, 233, 123, 51, 124, 196, 236, 11, 41, 68, 174, 170, 236, 211, 73, 52, 81, 15, 238, 150, 6, 236, 111, 242, 139, 76, 73, 204, 11, 182, 232, 197, 12, 42, 189, 201, 82, 174, 149, 246, 132, 2, 123, 21, 161, 13, 100, 231, 108, 198, 20, 245, 229]), this.Gq.parsePoint([202, 1, 47, 154, 82, 166, 142, 121, 173, 46, 142, 35, 130, 137, 181, 47, 125, 181, 195, 123, 126, 80, 241, 255, 0, 210, 228, 18, 47, 228, 185, 41, 214, 23, 90, 149, 215, 242, 76, 158, 34, 6, 157, 73, 235, 157, 226, 161, 27, 211, 131, 47, 217, 212, 109, 160, 237, 208, 219, 160, 136, 111, 179, 48, 165], [37, 90, 210, 207, 20, 64, 227, 18, 16, 243, 143, 167, 15, 252, 220, 246, 50, 229, 63, 184, 7, 47, 176, 234, 94, 241, 27, 108, 89, 14, 10, 168, 22, 22, 59, 162, 136, 20, 134, 84, 191, 181, 75, 113, 164, 227, 135, 211, 198, 62, 142, 76, 18, 245, 71, 157, 69, 41, 249, 252, 11, 44, 147, 89, 246]), this.Gq.parsePoint([31, 250, 67, 143, 240, 72, 186, 83, 156, 235, 55, 226, 51, 78, 202, 4, 200, 42, 247, 233, 190, 33, 12, 229, 21, 114, 219, 83, 203, 65, 233, 179, 38, 185, 164, 20, 138, 36, 153, 30, 102, 8, 253, 117, 59, 47, 52, 173, 254, 19, 171, 135, 230, 45, 200, 240, 119, 229, 186, 239, 67, 127, 88, 246, 13], [159, 112, 255, 35, 164, 102, 24, 163, 75, 160, 0, 231, 144, 84, 75, 161, 190, 187, 24, 249, 249, 151, 79, 126, 30, 8, 68, 165, 91, 154, 39, 1, 131, 161, 182, 187, 144, 91, 168, 118, 129, 249, 170, 99, 203, 57, 181, 127, 170, 201, 187, 147, 62, 149, 38, 184, 145, 178, 16, 153, 145, 194, 89, 251, 194]), this.Gq.parsePoint([48, 28, 182, 7, 93, 5, 107, 198, 94, 106, 227, 1, 192, 118, 117, 46, 7, 239, 45, 33, 241, 130, 206, 222, 66, 171, 111, 86, 240, 137, 219, 93, 80, 102, 15, 145, 26, 127, 133, 121, 115, 55, 161, 169, 80, 86, 212, 97, 59, 167, 92, 125, 105, 165, 188, 186, 236, 35, 98, 233, 76, 101, 150, 69, 101], [45, 238, 45, 205, 2, 174, 94, 61, 80, 52, 11, 56, 134, 219, 37, 192, 83, 110, 173, 235, 40, 125, 34, 171, 133, 36, 253, 243, 45, 64, 210, 1, 154, 146, 2, 249, 218, 143, 160, 121, 39, 82, 218, 250, 35, 160, 66, 192, 132, 244, 208, 140, 224, 121, 47, 70, 0, 59, 244, 119, 240, 168, 108, 172, 133]), this.Gq.parsePoint([64, 127, 200, 233, 132, 200, 70, 1, 243, 228, 25, 82, 254, 193, 97, 66, 48, 23, 224, 115, 211, 55, 131, 255, 5, 165, 14, 10, 17, 185, 76, 78, 190, 208, 200, 215, 103, 30, 81, 128, 249, 147, 177, 233, 209, 227, 87, 210, 145, 119, 39, 30, 178, 158, 251, 150, 205, 239, 78, 223, 157, 140, 107, 116, 64], [67, 29, 246, 155, 2, 32, 4, 202, 244, 199, 30, 206, 81, 105, 50, 2, 181, 16, 244, 2, 7, 228, 133, 110, 148, 9, 130, 21, 192, 31, 85, 193, 154, 7, 40, 199, 72, 28, 223, 194, 75, 47, 128, 209, 210, 41, 236, 218, 193, 244, 216, 62, 140, 70, 108, 211, 88, 111, 78, 13, 19, 255, 37, 233, 136]), this.Gq.parsePoint([1, 219, 172, 107, 224, 134, 7, 135, 222, 240, 63, 252, 84, 114, 220, 35, 250, 6, 177, 90, 240, 28, 191, 139, 238, 143, 90, 14, 113, 174, 40, 181, 236, 172, 150, 253, 168, 46, 133, 116, 116, 28, 33, 159, 166, 45, 49, 175, 214, 88, 187, 149, 120, 213, 155, 39, 157, 240, 148, 144, 99, 18, 38, 101, 207, 179], [54, 218, 26, 31, 191, 166, 92, 78, 233, 29, 131, 108, 47, 66, 74, 178, 132, 92, 214, 235, 121, 98, 80, 6, 101, 247, 69, 199, 168, 60, 77, 169, 158, 7, 207, 47, 87, 217, 158, 87, 105, 191, 167, 11, 219, 222, 132, 237, 229, 98, 80, 75, 142, 132, 178, 193, 225, 89, 240, 219, 185, 235, 88, 84, 155]), this.Gq.parsePoint([237, 166, 37, 222, 5, 131, 64, 33, 58, 133, 157, 249, 116, 129, 192, 98, 35, 51, 122, 180, 46, 69, 89, 155, 181, 67, 25, 96, 211, 185, 196, 51, 216, 126, 109, 240, 27, 220, 137, 90, 60, 16, 12, 245, 189, 53, 126, 66, 212, 205, 187, 158, 235, 71, 225, 146, 152, 2, 194, 14, 252, 101, 233, 224, 68], [201, 10, 14, 250, 22, 192, 187, 105, 142, 43, 103, 181, 189, 73, 138, 2, 216, 105, 92, 115, 242, 98, 106, 150, 221, 133, 55, 29, 200, 210, 54, 175, 111, 35, 66, 147, 208, 150, 34, 170, 16, 88, 133, 155, 54, 150, 31, 213, 159, 94, 40, 203, 72, 12, 32, 38, 36, 190, 244, 49, 134, 252, 205, 57, 110]), this.Gq.parsePoint([5, 248, 164, 153, 185, 60, 16, 196, 158, 30, 41, 172, 123, 164, 38, 113, 251, 70, 174, 141, 3, 32, 186, 203, 95, 1, 143, 69, 10, 88, 119, 192, 198, 54, 86, 238, 211, 200, 4, 59, 254, 18, 201, 52, 106, 106, 225, 248, 29, 219, 144, 249, 106, 15, 174, 249, 222, 243, 169, 134, 190, 204, 168, 86, 253], [99, 73, 93, 94, 202, 33, 242, 112, 227, 213, 153, 254, 243, 73, 34, 48, 236, 166, 76, 113, 43, 179, 16, 11, 20, 244, 174, 43, 98, 24, 171, 104, 53, 85, 120, 202, 115, 162, 106, 244, 200, 2, 2, 31, 58, 41, 156, 132, 211, 67, 170, 239, 35, 124, 26, 210, 5, 3, 83, 42, 70, 141, 190, 249, 165]), this.Gq.parsePoint([170, 134, 252, 209, 28, 180, 229, 21, 96, 33, 245, 17, 194, 20, 93, 241, 152, 216, 252, 7, 228, 55, 247, 73, 86, 4, 239, 211, 135, 16, 13, 106, 195, 56, 147, 78, 67, 7, 55, 111, 235, 27, 156, 210, 49, 247, 231, 78, 31, 247, 104, 22, 81, 137, 68, 45, 106, 133, 24, 88, 219, 68, 195, 148, 47], [70, 227, 69, 144, 108, 31, 169, 97, 167, 12, 236, 103, 31, 233, 132, 173, 98, 146, 110, 38, 175, 14, 73, 219, 175, 120, 8, 27, 212, 200, 10, 241, 66, 108, 179, 151, 233, 212, 20, 183, 194, 232, 48, 5, 190, 74, 177, 87, 31, 40, 67, 172, 212, 131, 77, 22, 11, 56, 244, 112, 76, 28, 45, 26, 55]), this.Gq.parsePoint([96, 186, 149, 56, 125, 82, 214, 244, 34, 95, 244, 194, 64, 196, 235, 6, 29, 109, 166, 1, 148, 103, 244, 168, 69, 132, 250, 232, 230, 133, 234, 236, 7, 143, 0, 100, 198, 252, 11, 91, 94, 71, 155, 218, 139, 25, 80, 143, 100, 170, 111, 107, 211, 33, 186, 59, 181, 89, 155, 31, 218, 11, 207, 15, 66], [208, 250, 217, 32, 30, 99, 75, 65, 240, 185, 252, 117, 151, 183, 123, 47, 228, 135, 225, 43, 131, 54, 159, 231, 255, 11, 101, 171, 221, 172, 146, 160, 45, 235, 26, 197, 76, 141, 110, 15, 94, 85, 37, 132, 48, 255, 97, 143, 209, 203, 240, 57, 73, 10, 3, 226, 110, 97, 16, 77, 128, 157, 228, 30, 69]), this.Gq.parsePoint([1, 236, 174, 136, 39, 167, 176, 148, 125, 170, 24, 94, 146, 144, 14, 92, 94, 242, 93, 236, 31, 8, 33, 184, 166, 151, 75, 218, 129, 146, 192, 123, 58, 60, 103, 105, 173, 253, 184, 87, 199, 60, 150, 116, 234, 210, 106, 59, 87, 165, 111, 166, 193, 90, 71, 50, 196, 189, 99, 6, 30, 28, 184, 215, 46, 162], [117, 208, 31, 93, 59, 56, 138, 22, 84, 107, 200, 62, 250, 127, 151, 67, 47, 208, 7, 30, 199, 229, 146, 147, 35, 43, 233, 198, 170, 72, 209, 174, 95, 167, 75, 160, 221, 139, 153, 235, 132, 9, 181, 77, 109, 129, 29, 22, 74, 244, 48, 133, 239, 134, 10, 58, 39, 119, 124, 3, 54, 36, 168, 246, 105]), this.Gq.parsePoint([180, 26, 128, 208, 205, 174, 29, 134, 191, 3, 33, 169, 173, 230, 191, 60, 193, 214, 11, 188, 50, 168, 205, 138, 210, 50, 200, 34, 142, 156, 21, 231, 92, 195, 114, 214, 202, 110, 90, 231, 13, 229, 254, 82, 2, 136, 57, 56, 180, 45, 242, 35, 102, 67, 86, 156, 14, 230, 167, 62, 9, 100, 84, 140, 29], [68, 187, 78, 160, 101, 154, 39, 230, 18, 172, 0, 136, 121, 73, 64, 15, 184, 244, 28, 158, 181, 218, 255, 137, 181, 238, 76, 233, 121, 250, 29, 115, 181, 234, 218, 31, 96, 55, 200, 224, 22, 228, 76, 28, 138, 79, 157, 194, 175, 72, 124, 217, 42, 25, 244, 80, 189, 113, 187, 77, 114, 62, 157, 4, 169]), this.Gq.parsePoint([215, 234, 126, 128, 69, 41, 243, 160, 136, 159, 236, 166, 50, 204, 105, 7, 162, 67, 137, 188, 11, 161, 238, 15, 100, 141, 82, 224, 192, 217, 23, 68, 53, 156, 169, 69, 224, 41, 66, 4, 169, 216, 169, 5, 108, 252, 22, 160, 19, 132, 244, 60, 123, 15, 226, 7, 243, 122, 129, 173, 21, 132, 85, 131, 27], [133, 250, 102, 238, 222, 109, 69, 45, 76, 128, 251, 146, 67, 187, 188, 213, 80, 13, 124, 55, 168, 122, 198, 135, 164, 156, 160, 32, 187, 240, 0, 21, 172, 213, 212, 39, 178, 226, 14, 115, 58, 5, 132, 156, 193, 61, 44, 32, 69, 197, 51, 61, 126, 193, 12, 200, 242, 166, 63, 99, 254, 120, 28, 189, 66]), this.Gq.parsePoint([108, 232, 127, 159, 91, 91, 111, 160, 251, 197, 28, 46, 58, 32, 17, 83, 11, 242, 22, 204, 3, 205, 234, 12, 53, 39, 51, 160, 218, 182, 239, 167, 255, 119, 239, 178, 22, 152, 214, 162, 163, 6, 151, 227, 91, 18, 140, 110, 226, 160, 46, 188, 148, 107, 125, 1, 214, 174, 249, 196, 56, 28, 18, 146, 95], [214, 3, 16, 22, 96, 50, 80, 19, 94, 25, 246, 187, 128, 134, 183, 81, 157, 34, 59, 8, 62, 184, 51, 244, 238, 219, 1, 140, 90, 130, 108, 226, 9, 41, 37, 182, 143, 139, 60, 130, 87, 104, 181, 135, 231, 64, 12, 87, 190, 44, 189, 90, 242, 218, 77, 154, 219, 253, 174, 9, 100, 31, 62, 182, 194]), this.Gq.parsePoint([1, 7, 79, 23, 22, 202, 29, 240, 15, 73, 73, 12, 133, 249, 196, 190, 35, 138, 227, 82, 158, 198, 178, 196, 155, 173, 207, 112, 47, 144, 180, 188, 207, 145, 81, 70, 251, 207, 160, 124, 242, 4, 152, 103, 126, 130, 244, 117, 114, 190, 217, 226, 187, 88, 84, 104, 169, 100, 125, 241, 170, 101, 177, 11, 75, 238], [227, 115, 93, 136, 26, 71, 19, 152, 200, 85, 78, 207, 125, 37, 245, 200, 113, 144, 198, 222, 26, 4, 181, 193, 62, 209, 104, 226, 55, 134, 145, 38, 111, 185, 143, 91, 213, 243, 54, 12, 182, 105, 205, 154, 77, 179, 47, 66, 246, 2, 81, 90, 116, 45, 254, 199, 173, 168, 66, 213, 149, 218, 108, 110, 61]), this.Gq.parsePoint([78, 10, 163, 185, 194, 231, 20, 115, 134, 250, 123, 237, 84, 62, 189, 212, 21, 232, 195, 50, 19, 193, 94, 40, 170, 138, 0, 62, 93, 179, 120, 232, 12, 177, 218, 238, 96, 2, 165, 20, 166, 115, 156, 143, 97, 141, 113, 16, 77, 188, 201, 209, 108, 113, 145, 238, 101, 201, 103, 204, 48, 104, 231, 31, 36], [8, 67, 126, 147, 191, 134, 219, 208, 234, 186, 56, 62, 243, 7, 221, 185, 141, 39, 174, 99, 231, 144, 51, 142, 133, 178, 120, 22, 128, 171, 11, 191, 225, 113, 36, 120, 86, 142, 18, 172, 237, 185, 118, 168, 243, 138, 37, 92, 135, 10, 197, 249, 127, 69, 20, 28, 9, 119, 70, 55, 112, 71, 146, 113, 101]), this.Gq.parsePoint([1, 38, 177, 230, 5, 227, 186, 228, 86, 201, 134, 173, 219, 110, 186, 15, 117, 2, 41, 179, 249, 113, 35, 94, 168, 39, 162, 225, 111, 69, 243, 169, 56, 118, 90, 240, 160, 129, 47, 162, 175, 1, 153, 226, 225, 128, 22, 121, 228, 58, 30, 249, 66, 23, 50, 89, 93, 186, 126, 113, 217, 246, 214, 140, 48, 207], [251, 134, 64, 228, 154, 95, 160, 156, 79, 205, 242, 195, 118, 17, 252, 57, 127, 95, 123, 89, 145, 112, 156, 198, 120, 59, 146, 136, 94, 233, 121, 132, 116, 68, 81, 181, 51, 213, 113, 12, 139, 128, 29, 94, 41, 206, 46, 55, 63, 195, 37, 243, 41, 167, 80, 45, 80, 63, 66, 62, 178, 163, 169, 212, 40]), this.Gq.parsePoint([128, 148, 233, 78, 25, 131, 167, 97, 26, 12, 214, 36, 217, 76, 250, 27, 60, 30, 24, 235, 210, 118, 127, 79, 65, 70, 197, 115, 223, 54, 130, 129, 105, 61, 223, 165, 38, 33, 122, 13, 147, 93, 34, 86, 165, 38, 200, 15, 229, 65, 128, 214, 59, 68, 197, 163, 196, 74, 82, 139, 178, 17, 208, 212, 11], [44, 87, 238, 255, 197, 18, 216, 48, 239, 249, 15, 138, 164, 31, 134, 113, 87, 146, 106, 229, 55, 39, 179, 101, 29, 41, 106, 103, 3, 135, 143, 150, 115, 143, 179, 8, 248, 92, 177, 83, 11, 57, 237, 36, 204, 182, 14, 170, 239, 128, 170, 34, 241, 202, 94, 154, 199, 148, 17, 10, 198, 205, 4, 141, 169]), this.Gq.parsePoint([1, 221, 201, 169, 145, 246, 24, 10, 190, 250, 174, 147, 81, 237, 206, 82, 77, 184, 176, 215, 228, 39, 195, 235, 165, 136, 23, 165, 8, 57, 111, 45, 191, 110, 26, 117, 67, 98, 126, 5, 195, 187, 230, 93, 254, 64, 208, 179, 49, 137, 64, 30, 241, 154, 177, 177, 111, 243, 59, 188, 68, 58, 95, 229, 71, 249], [250, 5, 204, 190, 33, 224, 187, 161, 136, 129, 220, 102, 42, 178, 159, 61, 156, 150, 17, 11, 42, 182, 15, 165, 80, 50, 33, 55, 122, 207, 176, 72, 81, 71, 154, 150, 18, 218, 185, 148, 218, 86, 114, 87, 29, 197, 196, 57, 63, 117, 178, 200, 74, 171, 63, 166, 160, 196, 73, 127, 14, 85, 177, 44, 178]), this.Gq.parsePoint([1, 235, 144, 53, 132, 6, 48, 172, 111, 208, 163, 1, 115, 169, 71, 147, 247, 232, 31, 52, 69, 94, 46, 26, 96, 15, 222, 192, 155, 182, 99, 97, 99, 198, 196, 178, 65, 117, 181, 96, 83, 230, 124, 62, 55, 77, 53, 115, 155, 227, 24, 25, 205, 231, 190, 252, 66, 235, 195, 174, 160, 171, 221, 3, 239, 199], [218, 85, 101, 180, 246, 22, 220, 225, 139, 233, 101, 127, 56, 111, 12, 39, 146, 252, 240, 246, 2, 198, 172, 248, 79, 203, 201, 118, 187, 39, 109, 109, 132, 151, 120, 117, 220, 18, 248, 135, 101, 74, 199, 194, 135, 60, 58, 239, 241, 192, 212, 92, 221, 206, 76, 214, 51, 40, 89, 138, 103, 176, 178, 34, 191]), this.Gq.parsePoint([1, 42, 140, 105, 92, 132, 150, 20, 233, 166, 161, 212, 179, 152, 139, 106, 86, 187, 206, 183, 128, 209, 205, 43, 43, 227, 55, 177, 114, 10, 39, 147, 111, 176, 94, 207, 162, 26, 172, 158, 153, 183, 3, 27, 218, 148, 33, 181, 179, 185, 85, 91, 170, 218, 201, 107, 171, 206, 138, 126, 228, 225, 226, 101, 117, 39], [12, 44, 40, 118, 63, 209, 227, 146, 208, 122, 226, 237, 150, 153, 18, 219, 108, 120, 184, 187, 250, 33, 110, 86, 82, 198, 251, 71, 115, 30, 196, 85, 147, 141, 162, 92, 23, 251, 88, 46, 165, 2, 40, 16, 48, 132, 151, 38, 244, 120, 202, 209, 168, 181, 107, 233, 33, 169, 11, 83, 97, 11, 98, 160, 156]), this.Gq.parsePoint([1, 48, 178, 116, 101, 173, 105, 198, 115, 44, 218, 17, 128, 80, 205, 221, 162, 136, 26, 8, 112, 241, 238, 156, 235, 216, 26, 86, 86, 117, 92, 182, 176, 128, 164, 40, 147, 139, 174, 209, 247, 214, 119, 42, 143, 85, 146, 52, 251, 162, 15, 211, 0, 249, 29, 136, 207, 249, 155, 121, 79, 31, 173, 100, 121, 212], [140, 101, 115, 168, 157, 155, 72, 217, 238, 132, 116, 215, 71, 82, 107, 205, 116, 178, 13, 84, 92, 66, 171, 117, 80, 214, 244, 144, 97, 252, 203, 9, 87, 156, 57, 230, 112, 188, 4, 190, 8, 32, 189, 47, 195, 154, 84, 17, 72, 96, 65, 186, 148, 228, 180, 5, 106, 25, 107, 7, 106, 34, 43, 224, 27]), this.Gq.parsePoint([1, 44, 174, 174, 98, 244, 45, 19, 20, 31, 194, 139, 245, 35, 47, 149, 219, 233, 220, 215, 33, 178, 89, 144, 65, 80, 125, 163, 165, 193, 70, 122, 25, 250, 70, 155, 160, 145, 64, 16, 102, 34, 230, 119, 113, 243, 50, 225, 155, 60, 23, 58, 253, 30, 35, 216, 69, 219, 150, 0, 190, 7, 85, 248, 94, 246], [236, 47, 145, 149, 210, 191, 15, 116, 159, 26, 115, 220, 19, 183, 97, 137, 36, 179, 211, 121, 219, 33, 41, 19, 113, 136, 185, 232, 229, 83, 53, 192, 150, 214, 58, 39, 245, 187, 2, 245, 180, 245, 172, 215, 197, 196, 186, 154, 123, 251, 248, 190, 175, 28, 55, 71, 217, 74, 178, 252, 95, 19, 16, 254, 216]), this.Gq.parsePoint([194, 24, 43, 166, 232, 32, 232, 173, 137, 172, 143, 98, 85, 33, 96, 171, 202, 189, 209, 71, 230, 63, 118, 154, 220, 105, 166, 35, 235, 236, 137, 16, 42, 168, 61, 250, 45, 109, 106, 246, 38, 59, 73, 122, 113, 80, 97, 14, 186, 106, 217, 130, 151, 162, 120, 235, 129, 214, 98, 194, 222, 243, 141, 224, 64], [154, 231, 224, 103, 21, 114, 97, 155, 115, 11, 51, 171, 220, 140, 154, 70, 8, 214, 65, 225, 99, 69, 99, 16, 190, 148, 207, 85, 174, 76, 146, 92, 111, 230, 58, 8, 31, 177, 65, 155, 102, 195, 168, 252, 25, 158, 126, 203, 17, 74, 155, 222, 177, 62, 231, 172, 243, 172, 126, 221, 67, 247, 34, 53, 24]), this.Gq.parsePoint([81, 124, 49, 38, 85, 99, 93, 65, 223, 94, 254, 143, 138, 243, 6, 119, 224, 227, 207, 90, 221, 72, 170, 177, 87, 244, 93, 255, 98, 21, 205, 207, 95, 92, 26, 212, 220, 52, 116, 188, 221, 64, 27, 250, 139, 119, 16, 59, 32, 201, 194, 137, 37, 161, 142, 191, 234, 205, 141, 43, 10, 29, 82, 212, 141], [93, 104, 48, 211, 60, 126, 223, 85, 77, 159, 20, 201, 230, 238, 80, 41, 102, 248, 51, 161, 197, 239, 80, 107, 110, 244, 75, 145, 113, 102, 78, 153, 229, 204, 28, 139, 9, 215, 4, 255, 158, 114, 208, 198, 14, 31, 124, 230, 230, 248, 152, 154, 136, 160, 59, 28, 48, 7, 52, 240, 148, 194, 197, 98, 76]), this.Gq.parsePoint([111, 32, 23, 218, 29, 92, 136, 39, 69, 132, 117, 44, 138, 184, 199, 239, 138, 231, 246, 169, 236, 235, 58, 139, 59, 154, 241, 107, 94, 3, 71, 176, 31, 166, 98, 176, 219, 39, 251, 171, 117, 116, 154, 230, 131, 87, 19, 95, 61, 210, 84, 77, 46, 26, 125, 149, 148, 191, 215, 215, 221, 249, 214, 156, 37], [214, 33, 149, 225, 78, 107, 41, 101, 65, 71, 219, 25, 208, 44, 215, 51, 129, 2, 13, 122, 85, 89, 136, 14, 62, 47, 65, 52, 62, 243, 155, 210, 155, 97, 61, 139, 85, 174, 51, 213, 89, 223, 54, 161, 125, 31, 164, 218, 224, 181, 163, 82, 244, 89, 22, 143, 148, 208, 165, 180, 86, 20, 112, 39, 44]), this.Gq.parsePoint([1, 246, 102, 66, 95, 168, 189, 233, 139, 255, 19, 129, 97, 121, 108, 18, 224, 225, 228, 133, 234, 218, 205, 14, 213, 173, 171, 23, 186, 146, 179, 162, 147, 40, 254, 5, 113, 150, 214, 122, 3, 108, 146, 47, 8, 116, 54, 233, 129, 135, 164, 37, 185, 34, 106, 231, 90, 10, 145, 184, 72, 173, 166, 122, 155, 224], [183, 141, 129, 82, 186, 174, 31, 226, 144, 24, 53, 100, 236, 12, 222, 221, 239, 98, 73, 34, 11, 152, 109, 248, 187, 243, 203, 154, 4, 127, 6, 98, 121, 211, 205, 7, 59, 93, 143, 24, 80, 138, 23, 247, 175, 204, 244, 7, 88, 50, 79, 226, 81, 197, 78, 43, 191, 221, 43, 225, 109, 220, 211, 90, 204]), this.Gq.parsePoint([28, 120, 170, 84, 118, 246, 204, 155, 109, 34, 195, 162, 88, 190, 188, 29, 242, 206, 46, 57, 29, 199, 117, 184, 20, 206, 206, 148, 246, 79, 237, 41, 192, 201, 164, 10, 231, 183, 143, 33, 129, 175, 22, 61, 236, 131, 24, 103, 132, 147, 209, 185, 133, 38, 6, 229, 143, 150, 55, 84, 101, 33, 65, 205, 27], [62, 76, 70, 129, 66, 204, 27, 111, 182, 65, 23, 198, 105, 127, 41, 195, 54, 253, 178, 114, 164, 131, 100, 35, 57, 216, 56, 34, 6, 3, 225, 29, 76, 109, 200, 11, 123, 30, 93, 19, 33, 171, 17, 160, 45, 125, 129, 162, 90, 20, 238, 213, 128, 140, 122, 9, 84, 129, 199, 185, 33, 109, 7, 101, 128]), this.Gq.parsePoint([1, 75, 227, 6, 194, 163, 12, 11, 144, 167, 65, 163, 125, 227, 130, 181, 101, 160, 120, 116, 113, 219, 211, 114, 111, 58, 222, 222, 122, 177, 253, 174, 129, 190, 89, 90, 217, 94, 102, 215, 226, 220, 245, 56, 117, 24, 186, 221, 227, 18, 142, 24, 243, 43, 193, 152, 203, 112, 15, 163, 184, 176, 252, 243, 135, 155], [200, 103, 193, 33, 203, 179, 66, 83, 198, 212, 237, 101, 199, 11, 226, 45, 22, 23, 182, 144, 12, 171, 206, 233, 40, 231, 107, 147, 189, 22, 186, 19, 212, 147, 209, 199, 30, 98, 112, 148, 221, 20, 214, 161, 178, 203, 174, 166, 69, 5, 204, 85, 36, 156, 151, 134, 151, 23, 3, 80, 39, 35, 219, 235, 35]), this.Gq.parsePoint([1, 249, 115, 37, 196, 85, 221, 59, 4, 213, 138, 121, 199, 109, 128, 228, 25, 214, 231, 88, 39, 132, 122, 75, 81, 72, 204, 50, 124, 52, 13, 230, 103, 10, 239, 229, 153, 136, 193, 182, 20, 154, 211, 157, 89, 73, 138, 254, 67, 79, 172, 40, 111, 81, 150, 125, 233, 225, 38, 229, 162, 58, 49, 6, 28, 130], [26, 164, 34, 172, 82, 245, 8, 67, 147, 244, 100, 7, 104, 237, 240, 194, 133, 143, 121, 8, 111, 146, 76, 227, 193, 128, 183, 241, 29, 145, 200, 212, 35, 95, 159, 116, 87, 89, 62, 200, 33, 221, 160, 106, 16, 121, 43, 214, 158, 195, 65, 186, 132, 177, 38, 8, 52, 44, 199, 21, 209, 205, 52, 47, 252]), this.Gq.parsePoint([175, 75, 14, 66, 116, 0, 168, 100, 175, 137, 154, 42, 86, 207, 101, 14, 244, 212, 168, 102, 88, 134, 2, 123, 188, 206, 124, 16, 4, 221, 114, 94, 180, 187, 98, 209, 183, 60, 94, 40, 92, 242, 174, 211, 205, 73, 12, 6, 255, 42, 22, 19, 235, 102, 31, 140, 10, 134, 115, 140, 174, 162, 245, 212, 217], [52, 148, 170, 110, 2, 232, 20, 58, 133, 122, 252, 154, 108, 121, 232, 108, 49, 187, 93, 231, 160, 27, 252, 202, 74, 87, 87, 47, 239, 55, 58, 52, 54, 227, 34, 153, 68, 204, 161, 94, 82, 101, 40, 162, 43, 15, 177, 163, 81, 86, 149, 168, 228, 223, 20, 24, 143, 129, 197, 85, 231, 128, 122, 63, 120]), this.Gq.parsePoint([53, 147, 152, 73, 23, 130, 77, 245, 201, 71, 2, 207, 215, 176, 91, 62, 177, 171, 247, 60, 186, 182, 42, 67, 223, 150, 113, 223, 97, 38, 161, 101, 162, 114, 125, 39, 153, 122, 43, 145, 29, 193, 82, 143, 228, 34, 99, 71, 124, 226, 232, 238, 139, 241, 236, 34, 201, 50, 69, 154, 218, 163, 117, 142, 13], [62, 0, 9, 85, 213, 104, 179, 53, 255, 4, 199, 240, 17, 248, 176, 174, 174, 46, 189, 6, 111, 133, 189, 230, 136, 130, 251, 132, 13, 5, 178, 145, 201, 79, 38, 110, 130, 102, 79, 35, 155, 150, 138, 203, 34, 4, 17, 181, 70, 212, 108, 182, 206, 114, 217, 140, 215, 166, 222, 197, 78, 36, 105, 182, 50]), this.Gq.parsePoint([1, 147, 32, 201, 147, 157, 242, 71, 17, 249, 132, 79, 3, 18, 170, 184, 14, 68, 118, 153, 228, 208, 114, 162, 217, 232, 10, 41, 218, 254, 134, 202, 240, 88, 250, 179, 168, 168, 212, 151, 85, 21, 134, 76, 43, 147, 28, 127, 125, 179, 178, 95, 47, 95, 158, 95, 139, 83, 21, 166, 129, 179, 147, 176, 138, 127], [171, 73, 5, 14, 164, 153, 37, 252, 28, 184, 106, 206, 223, 66, 25, 101, 155, 36, 144, 233, 27, 9, 244, 37, 191, 240, 81, 96, 10, 158, 49, 70, 78, 46, 169, 105, 116, 84, 91, 124, 116, 88, 56, 167, 90, 73, 200, 139, 202, 205, 131, 122, 200, 149, 127, 193, 79, 113, 29, 234, 147, 7, 15, 61, 153]), this.Gq.parsePoint([1, 43, 165, 181, 50, 172, 181, 206, 238, 156, 145, 163, 37, 105, 87, 134, 191, 126, 24, 66, 184, 49, 248, 218, 48, 211, 96, 212, 40, 174, 83, 62, 242, 209, 7, 30, 129, 49, 247, 167, 167, 41, 188, 46, 209, 154, 224, 193, 41, 184, 171, 3, 119, 251, 85, 224, 25, 230, 73, 50, 235, 40, 248, 11, 147, 52], [128, 60, 142, 190, 170, 73, 61, 111, 203, 53, 111, 178, 86, 43, 121, 211, 163, 118, 181, 188, 191, 155, 34, 187, 238, 117, 97, 16, 117, 247, 183, 171, 22, 102, 106, 189, 151, 190, 91, 126, 203, 51, 136, 65, 254, 119, 236, 225, 53, 244, 226, 228, 184, 58, 202, 253, 113, 231, 4, 82, 122, 132, 120, 148, 104]), this.Gq.parsePoint([160, 146, 238, 222, 209, 133, 250, 118, 130, 239, 126, 75, 42, 25, 138, 78, 160, 67, 165, 235, 166, 43, 68, 121, 168, 101, 125, 102, 217, 218, 183, 197, 222, 101, 228, 118, 66, 220, 198, 46, 42, 86, 30, 180, 148, 241, 226, 116, 140, 220, 121, 47, 1, 20, 199, 127, 82, 183, 215, 197, 245, 196, 176, 88, 131], [215, 74, 89, 74, 102, 29, 64, 234, 98, 151, 2, 221, 18, 71, 128, 143, 178, 136, 221, 80, 64, 229, 65, 13, 125, 107, 4, 89, 30, 57, 105, 107, 242, 153, 149, 163, 82, 57, 40, 65, 61, 116, 106, 207, 44, 219, 85, 196, 10, 160, 132, 203, 101, 162, 137, 189, 252, 133, 1, 253, 204, 180, 2, 9, 249]), this.Gq.parsePoint([239, 69, 30, 17, 13, 175, 157, 94, 57, 26, 83, 89, 147, 74, 159, 105, 105, 81, 127, 67, 140, 123, 234, 24, 61, 94, 150, 41, 13, 220, 225, 32, 135, 62, 69, 72, 109, 12, 65, 200, 135, 196, 131, 180, 102, 29, 251, 72, 216, 215, 44, 15, 184, 158, 135, 227, 156, 138, 55, 22, 233, 205, 199, 109, 221], [239, 165, 198, 141, 20, 222, 14, 255, 29, 114, 144, 5, 226, 110, 116, 244, 159, 139, 192, 131, 18, 74, 67, 42, 225, 141, 213, 19, 28, 4, 119, 111, 89, 163, 249, 50, 116, 197, 23, 127, 60, 145, 162, 1, 96, 101, 122, 17, 79, 91, 192, 219, 204, 92, 128, 105, 152, 78, 52, 19, 32, 65, 42, 223, 26]), this.Gq.parsePoint([1, 24, 113, 63, 161, 26, 83, 162, 75, 51, 249, 225, 86, 206, 207, 139, 65, 88, 116, 121, 69, 8, 254, 84, 56, 248, 196, 218, 225, 56, 102, 106, 91, 136, 142, 142, 153, 67, 141, 171, 193, 85, 86, 70, 87, 71, 17, 106, 196, 114, 173, 149, 210, 146, 15, 233, 179, 111, 48, 190, 9, 99, 215, 224, 219, 18], [149, 75, 234, 95, 97, 228, 169, 216, 208, 147, 209, 185, 214, 171, 82, 178, 250, 200, 183, 134, 85, 128, 32, 16, 207, 94, 217, 116, 89, 134, 66, 113, 239, 76, 52, 216, 4, 76, 38, 199, 118, 61, 227, 40, 229, 9, 239, 10, 104, 193, 23, 49, 48, 173, 99, 1, 178, 12, 59, 200, 248, 242, 106, 210, 150]), this.Gq.parsePoint([1, 33, 11, 142, 253, 144, 243, 185, 236, 13, 143, 63, 130, 246, 135, 138, 191, 84, 168, 143, 240, 104, 114, 6, 78, 183, 244, 233, 3, 181, 48, 148, 92, 90, 127, 11, 227, 179, 13, 0, 72, 1, 112, 10, 227, 221, 37, 50, 127, 75, 194, 134, 8, 190, 81, 47, 128, 10, 132, 84, 223, 141, 21, 6, 154, 24], [142, 110, 252, 18, 170, 213, 71, 179, 224, 141, 57, 247, 167, 158, 155, 3, 70, 22, 240, 152, 23, 95, 113, 101, 97, 183, 146, 122, 177, 21, 165, 75, 228, 253, 236, 211, 132, 95, 127, 83, 88, 130, 143, 23, 91, 131, 237, 37, 239, 36, 146, 200, 114, 150, 214, 216, 158, 203, 152, 129, 16, 75, 233, 190, 125]), this.Gq.parsePoint([1, 251, 215, 140, 148, 236, 82, 229, 215, 105, 57, 44, 240, 132, 197, 230, 41, 178, 156, 246, 227, 187, 167, 243, 205, 12, 97, 44, 47, 97, 12, 227, 136, 187, 114, 169, 199, 212, 221, 195, 245, 97, 32, 134, 203, 66, 191, 52, 15, 30, 74, 199, 50, 76, 115, 89, 239, 51, 81, 9, 92, 176, 10, 122, 48, 78], [153, 221, 131, 209, 180, 192, 178, 113, 245, 28, 72, 81, 178, 54, 255, 123, 126, 134, 98, 102, 128, 104, 71, 150, 25, 55, 239, 32, 174, 204, 152, 129, 34, 192, 118, 3, 38, 116, 190, 81, 58, 160, 57, 70, 22, 52, 119, 221, 210, 5, 148, 91, 57, 23, 209, 163, 252, 204, 162, 186, 157, 66, 5, 175, 247]), this.Gq.parsePoint([236, 234, 218, 227, 96, 126, 166, 170, 43, 101, 79, 246, 127, 12, 21, 105, 172, 195, 35, 186, 62, 109, 204, 90, 248, 236, 234, 48, 187, 164, 53, 190, 26, 98, 154, 116, 217, 226, 55, 54, 251, 147, 243, 190, 175, 207, 237, 45, 54, 213, 158, 35, 49, 123, 208, 253, 31, 149, 155, 212, 88, 110, 121, 248, 158], [249, 115, 86, 40, 163, 130, 226, 173, 132, 253, 27, 173, 235, 207, 108, 158, 229, 227, 151, 137, 57, 29, 230, 191, 180, 9, 176, 173, 172, 193, 115, 16, 80, 84, 17, 139, 68, 60, 180, 237, 162, 50, 66, 143, 68, 19, 24, 58, 86, 72, 109, 7, 59, 132, 165, 109, 137, 203, 114, 30, 201, 133, 235, 199, 81]), this.Gq.parsePoint([210, 37, 243, 157, 16, 96, 12, 199, 97, 193, 127, 225, 90, 206, 139, 186, 220, 119, 106, 186, 40, 188, 186, 228, 130, 209, 95, 121, 254, 56, 221, 11, 194, 201, 189, 225, 45, 110, 226, 80, 72, 157, 14, 122, 35, 72, 135, 17, 133, 127, 185, 19, 222, 116, 68, 22, 118, 253, 60, 152, 218, 78, 143, 216, 246], [151, 179, 244, 53, 192, 4, 22, 165, 149, 134, 231, 89, 49, 40, 193, 43, 115, 71, 35, 170, 136, 127, 152, 160, 180, 130, 209, 141, 56, 112, 123, 185, 51, 228, 180, 188, 204, 220, 113, 7, 95, 81, 116, 232, 242, 19, 59, 116, 181, 68, 178, 154, 121, 107, 79, 216, 183, 131, 102, 74, 241, 211, 101, 158, 153]), this.Gq.parsePoint([219, 204, 139, 184, 140, 0, 197, 49, 137, 11, 204, 34, 162, 242, 33, 184, 202, 145, 107, 156, 50, 76, 8, 28, 113, 35, 229, 202, 102, 6, 158, 11, 202, 201, 30, 9, 191, 149, 250, 231, 209, 95, 138, 172, 170, 23, 38, 215, 10, 192, 48, 87, 247, 216, 111, 14, 39, 55, 108, 204, 31, 205, 123, 140, 126], [45, 64, 1, 97, 93, 98, 93, 81, 38, 58, 111, 123, 242, 99, 192, 226, 28, 101, 104, 100, 189, 155, 57, 92, 23, 52, 54, 108, 227, 117, 81, 140, 5, 138, 52, 231, 72, 17, 193, 76, 160, 114, 39, 186, 160, 189, 11, 89, 201, 83, 86, 244, 127, 68, 243, 144, 198, 164, 209, 108, 74, 110, 12, 111, 236]), this.Gq.parsePoint([1, 4, 92, 173, 83, 93, 146, 54, 213, 70, 208, 161, 56, 90, 62, 164, 30, 101, 134, 238, 10, 118, 198, 255, 91, 129, 204, 136, 124, 181, 142, 162, 89, 229, 82, 20, 200, 40, 145, 96, 220, 25, 33, 196, 18, 228, 21, 139, 224, 203, 84, 184, 6, 65, 203, 101, 124, 135, 58, 92, 168, 78, 240, 229, 188, 90], [86, 236, 159, 0, 165, 189, 57, 167, 133, 120, 54, 35, 90, 131, 242, 75, 33, 255, 137, 184, 84, 132, 200, 167, 149, 254, 62, 59, 174, 237, 133, 50, 238, 43, 148, 25, 140, 152, 130, 3, 92, 119, 177, 231, 80, 133, 197, 203, 147, 109, 243, 6, 62, 113, 115, 89, 46, 39, 73, 9, 154, 98, 36, 125, 109]), this.Gq.parsePoint([139, 122, 247, 55, 140, 234, 232, 93, 85, 11, 218, 82, 236, 103, 68, 19, 59, 192, 237, 89, 61, 97, 42, 71, 24, 164, 59, 15, 133, 176, 87, 247, 159, 67, 70, 41, 177, 112, 210, 3, 165, 122, 196, 192, 6, 220, 76, 135, 181, 201, 47, 167, 212, 175, 55, 213, 227, 101, 26, 20, 21, 49, 252, 21, 26], [9, 68, 12, 98, 22, 180, 97, 7, 178, 83, 196, 11, 215, 15, 197, 252, 150, 254, 155, 136, 108, 243, 41, 64, 149, 138, 128, 36, 192, 133, 149, 249, 10, 109, 120, 63, 64, 164, 139, 30, 169, 187, 200, 224, 173, 187, 142, 77, 135, 48, 10, 202, 127, 113, 42, 128, 32, 176, 196, 61, 59, 31, 215, 148, 177]), this.Gq.parsePoint([99, 16, 90, 31, 240, 68, 157, 77, 93, 120, 131, 149, 238, 113, 65, 253, 92, 68, 253, 2, 39, 179, 189, 195, 43, 158, 157, 38, 190, 92, 123, 121, 69, 250, 248, 171, 36, 126, 237, 110, 80, 203, 130, 74, 190, 127, 92, 75, 126, 217, 237, 114, 88, 146, 210, 119, 173, 164, 98, 187, 78, 114, 221, 94, 109], [203, 2, 128, 229, 233, 41, 61, 45, 176, 141, 37, 202, 173, 30, 123, 73, 170, 82, 252, 133, 79, 164, 148, 2, 224, 94, 75, 111, 188, 240, 239, 193, 118, 72, 52, 193, 196, 202, 19, 163, 108, 162, 14, 139, 143, 87, 189, 119, 172, 168, 245, 43, 224, 107, 217, 166, 146, 159, 147, 202, 23, 45, 61, 134, 208]), this.Gq.parsePoint([208, 191, 198, 157, 149, 127, 47, 195, 142, 81, 112, 172, 58, 174, 129, 17, 13, 204, 122, 7, 124, 0, 148, 221, 210, 159, 241, 32, 87, 252, 175, 86, 232, 208, 20, 208, 22, 153, 142, 68, 113, 13, 179, 253, 247, 45, 166, 94, 49, 205, 102, 90, 188, 179, 83, 8, 166, 176, 172, 95, 24, 179, 255, 182, 247], [191, 171, 161, 183, 234, 84, 85, 43, 147, 140, 232, 157, 9, 7, 121, 127, 95, 85, 221, 8, 28, 163, 251, 92, 240, 31, 38, 6, 212, 100, 227, 110, 58, 55, 224, 80, 207, 160, 251, 156, 238, 224, 53, 54, 112, 124, 109, 17, 118, 101, 179, 177, 232, 52, 77, 102, 147, 155, 41, 121, 32, 4, 71, 80, 83])]; this.gt = this.Gq.parsePoint([208, 191, 198, 157, 149, 127, 47, 195, 142, 81, 112, 172, 58, 174, 129, 17, 13, 204, 122, 7, 124, 0, 148, 221, 210, 159, 241, 32, 87, 252, 175, 86, 232, 208, 20, 208, 22, 153, 142, 68, 113, 13, 179, 253, 247, 45, 166, 94, 49, 205, 102, 90, 188, 179, 83, 8, 166, 176, 172, 95, 24, 179, 255, 182, 247], [191, 171, 161, 183, 234, 84, 85, 43, 147, 140, 232, 157, 9, 7, 121, 127, 95, 85, 221, 8, 28, 163, 251, 92, 240, 31, 38, 6, 212, 100, 227, 110, 58, 55, 224, 80, 207, 160, 251, 156, 238, 224, 53, 54, 112, 124, 109, 17, 118, 101, 179, 177, 232, 52, 77, 102, 147, 155, 41, 121, 32, 4, 71, 80, 83]) } } function getEcGroup(descGq) { if (descGq == ECGroup.P256) { return new P256ECGroupParams } else if (descGq == ECGroup.P384) { return new P384ECGroupParams } else if (descGq == ECGroup.P521) { return new P521ECGroupParams } else { throw "invalid group:" + descGq } } var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}; var lookup = []; var revLookup = []; var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array; var inited = false; function init() { inited = true; var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; for (var i = 0, len = code.length; i < len; ++i){ lookup[i] = code[i]; revLookup[code.charCodeAt(i)] = i } revLookup["-".charCodeAt(0)] = 62; revLookup["_".charCodeAt(0)] = 63 } function toByteArray(b64) { if (!inited) { init() } var i, j, l, tmp, placeHolders, arr; var len = b64.length; if (len % 4 > 0) { throw new Error("Invalid string. Length must be a multiple of 4") } placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0; arr = new Arr(len * 3 / 4 - placeHolders); l = placeHolders > 0 ? len - 4 : len; var L = 0; for (i = 0, j = 0; i < l; i += 4, j += 3){ tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)]; arr[L++] = tmp >> 16 & 255; arr[L++] = tmp >> 8 & 255; arr[L++] = tmp & 255 } if (placeHolders === 2) { tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4; arr[L++] = tmp & 255 } else if (placeHolders === 1) { tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2; arr[L++] = tmp >> 8 & 255; arr[L++] = tmp & 255 } return arr } function tripletToBase64(num) { return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63] } function encodeChunk(uint8, start, end) { var tmp; var output = []; for (var i = start; i < end; i += 3){ tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2]; output.push(tripletToBase64(tmp)) } return output.join("") } function fromByteArray(uint8) { if (!inited) { init() } var tmp; var len = uint8.length; var extraBytes = len % 3; var output = ""; var parts = []; var maxChunkLength = 16383; for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength){ parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength)) } if (extraBytes === 1) { tmp = uint8[len - 1]; output += lookup[tmp >> 2]; output += lookup[tmp << 4 & 63]; output += "==" } else if (extraBytes === 2) { tmp = (uint8[len - 2] << 8) + uint8[len - 1]; output += lookup[tmp >> 10]; output += lookup[tmp >> 4 & 63]; output += lookup[tmp << 2 & 63]; output += "=" } parts.push(output); return parts.join("") } function read(buffer, offset, isLE, mLen, nBytes) { var e, m; var eLen = nBytes * 8 - mLen - 1; var eMax = (1 << eLen) - 1; var eBias = eMax >> 1; var nBits = -7; var i = isLE ? nBytes - 1 : 0; var d = isLE ? -1 : 1; var s = buffer[offset + i]; i += d; e = s & (1 << -nBits) - 1; s >>= -nBits; nBits += eLen; for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8){ } m = e & (1 << -nBits) - 1; e >>= -nBits; nBits += mLen; for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8){ } if (e === 0) { e = 1 - eBias } else if (e === eMax) { return m ? NaN : (s ? -1 : 1) * Infinity } else { m = m + Math.pow(2, mLen); e = e - eBias } return (s ? -1 : 1) * m * Math.pow(2, e - mLen) } function write(buffer, value, offset, isLE, mLen, nBytes) { var e, m, c; var eLen = nBytes * 8 - mLen - 1; var eMax = (1 << eLen) - 1; var eBias = eMax >> 1; var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0; var i = isLE ? 0 : nBytes - 1; var d = isLE ? 1 : -1; var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0; value = Math.abs(value); if (isNaN(value) || value === Infinity) { m = isNaN(value) ? 1 : 0; e = eMax } else { e = Math.floor(Math.log(value) / Math.LN2); if (value * (c = Math.pow(2, -e)) < 1) { e--; c *= 2 } if (e + eBias >= 1) { value += rt / c } else { value += rt * Math.pow(2, 1 - eBias) } if (value * c >= 2) { e++; c /= 2 } if (e + eBias >= eMax) { m = 0; e = eMax } else if (e + eBias >= 1) { m = (value * c - 1) * Math.pow(2, mLen); e = e + eBias } else { m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen); e = 0 } } for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8){ } e = e << mLen | m; eLen += mLen; for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8){ } buffer[offset + i - d] |= s * 128 } var toString = {}.toString; var isArray = Array.isArray || function (arr) { return toString.call(arr) == "[object Array]" }; var INSPECT_MAX_BYTES = 50; Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined ? global$1.TYPED_ARRAY_SUPPORT : true; kMaxLength(); function kMaxLength() { return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823 } function createBuffer(that, length) { if (kMaxLength() < length) { throw new RangeError("Invalid typed array length") } if (Buffer.TYPED_ARRAY_SUPPORT) { that = new Uint8Array(length); that.__proto__ = Buffer.prototype } else { if (that === null) { that = new Buffer(length) } that.length = length } return that } function Buffer(arg, encodingOrOffset, length) { if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) { return new Buffer(arg, encodingOrOffset, length) } if (typeof arg === "number") { if (typeof encodingOrOffset === "string") { throw new Error("If encoding is specified then the first argument must be a string") } return allocUnsafe(this, arg) } return from(this, arg, encodingOrOffset, length) } Buffer.poolSize = 8192; Buffer._augment = function (arr) { arr.__proto__ = Buffer.prototype; return arr }; function from(that, value, encodingOrOffset, length) { if (typeof value === "number") { throw new TypeError('"value" argument must not be a number') } if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) { return fromArrayBuffer(that, value, encodingOrOffset, length) } if (typeof value === "string") { return fromString(that, value, encodingOrOffset) } return fromObject(that, value) } Buffer.from = function (value, encodingOrOffset, length) { return from(null, value, encodingOrOffset, length) }; if (Buffer.TYPED_ARRAY_SUPPORT) { Buffer.prototype.__proto__ = Uint8Array.prototype; Buffer.__proto__ = Uint8Array } function assertSize(size) { if (typeof size !== "number") { throw new TypeError('"size" argument must be a number') } else if (size < 0) { throw new RangeError('"size" argument must not be negative') } } function alloc(that, size, fill, encoding) { assertSize(size); if (size <= 0) { return createBuffer(that, size) } if (fill !== undefined) { return typeof encoding === "string" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill) } return createBuffer(that, size) } Buffer.alloc = function (size, fill, encoding) { return alloc(null, size, fill, encoding) }; function allocUnsafe(that, size) { assertSize(size); that = createBuffer(that, size < 0 ? 0 : checked(size) | 0); if (!Buffer.TYPED_ARRAY_SUPPORT) { for (var i = 0; i < size; ++i){ that[i] = 0 } } return that } Buffer.allocUnsafe = function (size) { return allocUnsafe(null, size) }; Buffer.allocUnsafeSlow = function (size) { return allocUnsafe(null, size) }; function fromString(that, string, encoding) { if (typeof encoding !== "string" || encoding === "") { encoding = "utf8" } if (!Buffer.isEncoding(encoding)) { throw new TypeError('"encoding" must be a valid string encoding') } var length = byteLength(string, encoding) | 0; that = createBuffer(that, length); var actual = that.write(string, encoding); if (actual !== length) { that = that.slice(0, actual) } return that } function fromArrayLike(that, array) { var length = array.length < 0 ? 0 : checked(array.length) | 0; that = createBuffer(that, length); for (var i = 0; i < length; i += 1){ that[i] = array[i] & 255 } return that } function fromArrayBuffer(that, array, byteOffset, length) { array.byteLength; if (byteOffset < 0 || array.byteLength < byteOffset) { throw new RangeError("'offset' is out of bounds") } if (array.byteLength < byteOffset + (length || 0)) { throw new RangeError("'length' is out of bounds") } if (byteOffset === undefined && length === undefined) { array = new Uint8Array(array) } else if (length === undefined) { array = new Uint8Array(array, byteOffset) } else { array = new Uint8Array(array, byteOffset, length) } if (Buffer.TYPED_ARRAY_SUPPORT) { that = array; that.__proto__ = Buffer.prototype } else { that = fromArrayLike(that, array) } return that } function fromObject(that, obj) { if (internalIsBuffer(obj)) { var len = checked(obj.length) | 0; that = createBuffer(that, len); if (that.length === 0) { return that } obj.copy(that, 0, 0, len); return that } if (obj) { if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) { if (typeof obj.length !== "number" || isnan(obj.length)) { return createBuffer(that, 0) } return fromArrayLike(that, obj) } if (obj.type === "Buffer" && isArray(obj.data)) { return fromArrayLike(that, obj.data) } } throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.") } function checked(length) { if (length >= kMaxLength()) { throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + kMaxLength().toString(16) + " bytes") } return length | 0 } Buffer.isBuffer = isBuffer; function internalIsBuffer(b) { return !!(b != null && b._isBuffer) } Buffer.compare = function compare(a, b) { if (!internalIsBuffer(a) || !internalIsBuffer(b)) { throw new TypeError("Arguments must be Buffers") } if (a === b) return 0; var x = a.length; var y = b.length; for (var i = 0, len = Math.min(x, y); i < len; ++i){ if (a[i] !== b[i]) { x = a[i]; y = b[i]; break } } if (x < y) return -1; if (y < x) return 1; return 0 }; Buffer.isEncoding = function isEncoding(encoding) { switch (String(encoding).toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "latin1": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return true; default: return false } }; Buffer.concat = function concat(list, length) { if (!isArray(list)) { throw new TypeError('"list" argument must be an Array of Buffers') } if (list.length === 0) { return Buffer.alloc(0) } var i; if (length === undefined) { length = 0; for (i = 0; i < list.length; ++i){ length += list[i].length } } var buffer = Buffer.allocUnsafe(length); var pos = 0; for (i = 0; i < list.length; ++i){ var buf = list[i]; if (!internalIsBuffer(buf)) { throw new TypeError('"list" argument must be an Array of Buffers') } buf.copy(buffer, pos); pos += buf.length } return buffer }; function byteLength(string, encoding) { if (internalIsBuffer(string)) { return string.length } if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) { return string.byteLength } if (typeof string !== "string") { string = "" + string } var len = string.length; if (len === 0) return 0; var loweredCase = false; for (; ;){ switch (encoding) { case "ascii": case "latin1": case "binary": return len; case "utf8": case "utf-8": case undefined: return utf8ToBytes(string).length; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return len * 2; case "hex": return len >>> 1; case "base64": return base64ToBytes(string).length; default: if (loweredCase) return utf8ToBytes(string).length; encoding = ("" + encoding).toLowerCase(); loweredCase = true } } } Buffer.byteLength = byteLength; function slowToString(encoding, start, end) { var loweredCase = false; if (start === undefined || start < 0) { start = 0 } if (start > this.length) { return "" } if (end === undefined || end > this.length) { end = this.length } if (end <= 0) { return "" } end >>>= 0; start >>>= 0; if (end <= start) { return "" } if (!encoding) encoding = "utf8"; while (true) { switch (encoding) { case "hex": return hexSlice(this, start, end); case "utf8": case "utf-8": return utf8Slice(this, start, end); case "ascii": return asciiSlice(this, start, end); case "latin1": case "binary": return latin1Slice(this, start, end); case "base64": return base64Slice(this, start, end); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return utf16leSlice(this, start, end); default: if (loweredCase) throw new TypeError("Unknown encoding: " + encoding); encoding = (encoding + "").toLowerCase(); loweredCase = true } } } Buffer.prototype._isBuffer = true; function swap(b, n, m) { var i = b[n]; b[n] = b[m]; b[m] = i } Buffer.prototype.swap16 = function swap16() { var len = this.length; if (len % 2 !== 0) { throw new RangeError("Buffer size must be a multiple of 16-bits") } for (var i = 0; i < len; i += 2){ swap(this, i, i + 1) } return this }; Buffer.prototype.swap32 = function swap32() { var len = this.length; if (len % 4 !== 0) { throw new RangeError("Buffer size must be a multiple of 32-bits") } for (var i = 0; i < len; i += 4){ swap(this, i, i + 3); swap(this, i + 1, i + 2) } return this }; Buffer.prototype.swap64 = function swap64() { var len = this.length; if (len % 8 !== 0) { throw new RangeError("Buffer size must be a multiple of 64-bits") } for (var i = 0; i < len; i += 8){ swap(this, i, i + 7); swap(this, i + 1, i + 6); swap(this, i + 2, i + 5); swap(this, i + 3, i + 4) } return this }; Buffer.prototype.toString = function toString() { var length = this.length | 0; if (length === 0) return ""; if (arguments.length === 0) return utf8Slice(this, 0, length); return slowToString.apply(this, arguments) }; Buffer.prototype.equals = function equals(b) { if (!internalIsBuffer(b)) throw new TypeError("Argument must be a Buffer"); if (this === b) return true; return Buffer.compare(this, b) === 0 }; Buffer.prototype.inspect = function inspect() { var str = ""; var max = INSPECT_MAX_BYTES; if (this.length > 0) { str = this.toString("hex", 0, max).match(/.{2}/g).join(" "); if (this.length > max) str += " ... " } return "<Buffer " + str + ">" }; Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) { if (!internalIsBuffer(target)) { throw new TypeError("Argument must be a Buffer") } if (start === undefined) { start = 0 } if (end === undefined) { end = target ? target.length : 0 } if (thisStart === undefined) { thisStart = 0 } if (thisEnd === undefined) { thisEnd = this.length } if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) { throw new RangeError("out of range index") } if (thisStart >= thisEnd && start >= end) { return 0 } if (thisStart >= thisEnd) { return -1 } if (start >= end) { return 1 } start >>>= 0; end >>>= 0; thisStart >>>= 0; thisEnd >>>= 0; if (this === target) return 0; var x = thisEnd - thisStart; var y = end - start; var len = Math.min(x, y); var thisCopy = this.slice(thisStart, thisEnd); var targetCopy = target.slice(start, end); for (var i = 0; i < len; ++i){ if (thisCopy[i] !== targetCopy[i]) { x = thisCopy[i]; y = targetCopy[i]; break } } if (x < y) return -1; if (y < x) return 1; return 0 }; function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) { if (buffer.length === 0) return -1; if (typeof byteOffset === "string") { encoding = byteOffset; byteOffset = 0 } else if (byteOffset > 2147483647) { byteOffset = 2147483647 } else if (byteOffset < -2147483648) { byteOffset = -2147483648 } byteOffset = +byteOffset; if (isNaN(byteOffset)) { byteOffset = dir ? 0 : buffer.length - 1 } if (byteOffset < 0) byteOffset = buffer.length + byteOffset; if (byteOffset >= buffer.length) { if (dir) return -1; else byteOffset = buffer.length - 1 } else if (byteOffset < 0) { if (dir) byteOffset = 0; else return -1 } if (typeof val === "string") { val = Buffer.from(val, encoding) } if (internalIsBuffer(val)) { if (val.length === 0) { return -1 } return arrayIndexOf(buffer, val, byteOffset, encoding, dir) } else if (typeof val === "number") { val = val & 255; if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") { if (dir) { return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset) } else { return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset) } } return arrayIndexOf(buffer, [val], byteOffset, encoding, dir) } throw new TypeError("val must be string, number or Buffer") } function arrayIndexOf(arr, val, byteOffset, encoding, dir) { var indexSize = 1; var arrLength = arr.length; var valLength = val.length; if (encoding !== undefined) { encoding = String(encoding).toLowerCase(); if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") { if (arr.length < 2 || val.length < 2) { return -1 } indexSize = 2; arrLength /= 2; valLength /= 2; byteOffset /= 2 } } function read(buf, i) { if (indexSize === 1) { return buf[i] } else { return buf.readUInt16BE(i * indexSize) } } var i; if (dir) { var foundIndex = -1; for (i = byteOffset; i < arrLength; i++){ if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) { if (foundIndex === -1) foundIndex = i; if (i - foundIndex + 1 === valLength) return foundIndex * indexSize } else { if (foundIndex !== -1) i -= i - foundIndex; foundIndex = -1 } } } else { if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength; for (i = byteOffset; i >= 0; i--){ var found = true; for (var j = 0; j < valLength; j++){ if (read(arr, i + j) !== read(val, j)) { found = false; break } } if (found) return i } } return -1 } Buffer.prototype.includes = function includes(val, byteOffset, encoding) { return this.indexOf(val, byteOffset, encoding) !== -1 }; Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) { return bidirectionalIndexOf(this, val, byteOffset, encoding, true) }; Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) { return bidirectionalIndexOf(this, val, byteOffset, encoding, false) }; function hexWrite(buf, string, offset, length) { offset = Number(offset) || 0; var remaining = buf.length - offset; if (!length) { length = remaining } else { length = Number(length); if (length > remaining) { length = remaining } } var strLen = string.length; if (strLen % 2 !== 0) throw new TypeError("Invalid hex string"); if (length > strLen / 2) { length = strLen / 2 } for (var i = 0; i < length; ++i){ var parsed = parseInt(string.substr(i * 2, 2), 16); if (isNaN(parsed)) return i; buf[offset + i] = parsed } return i } function utf8Write(buf, string, offset, length) { return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length) } function asciiWrite(buf, string, offset, length) { return blitBuffer(asciiToBytes(string), buf, offset, length) } function latin1Write(buf, string, offset, length) { return asciiWrite(buf, string, offset, length) } function base64Write(buf, string, offset, length) { return blitBuffer(base64ToBytes(string), buf, offset, length) } function ucs2Write(buf, string, offset, length) { return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length) } Buffer.prototype.write = function write(string, offset, length, encoding) { if (offset === undefined) { encoding = "utf8"; length = this.length; offset = 0 } else if (length === undefined && typeof offset === "string") { encoding = offset; length = this.length; offset = 0 } else if (isFinite(offset)) { offset = offset | 0; if (isFinite(length)) { length = length | 0; if (encoding === undefined) encoding = "utf8" } else { encoding = length; length = undefined } } else { throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported") } var remaining = this.length - offset; if (length === undefined || length > remaining) length = remaining; if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) { throw new RangeError("Attempt to write outside buffer bounds") } if (!encoding) encoding = "utf8"; var loweredCase = false; for (; ;){ switch (encoding) { case "hex": return hexWrite(this, string, offset, length); case "utf8": case "utf-8": return utf8Write(this, string, offset, length); case "ascii": return asciiWrite(this, string, offset, length); case "latin1": case "binary": return latin1Write(this, string, offset, length); case "base64": return base64Write(this, string, offset, length); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return ucs2Write(this, string, offset, length); default: if (loweredCase) throw new TypeError("Unknown encoding: " + encoding); encoding = ("" + encoding).toLowerCase(); loweredCase = true } } }; Buffer.prototype.toJSON = function toJSON() { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) } }; function base64Slice(buf, start, end) { if (start === 0 && end === buf.length) { return fromByteArray(buf) } else { return fromByteArray(buf.slice(start, end)) } } function utf8Slice(buf, start, end) { end = Math.min(buf.length, end); var res = []; var i = start; while (i < end) { var firstByte = buf[i]; var codePoint = null; var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1; if (i + bytesPerSequence <= end) { var secondByte, thirdByte, fourthByte, tempCodePoint; switch (bytesPerSequence) { case 1: if (firstByte < 128) { codePoint = firstByte } break; case 2: secondByte = buf[i + 1]; if ((secondByte & 192) === 128) { tempCodePoint = (firstByte & 31) << 6 | secondByte & 63; if (tempCodePoint > 127) { codePoint = tempCodePoint } } break; case 3: secondByte = buf[i + 1]; thirdByte = buf[i + 2]; if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) { tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63; if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) { codePoint = tempCodePoint } } break; case 4: secondByte = buf[i + 1]; thirdByte = buf[i + 2]; fourthByte = buf[i + 3]; if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) { tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63; if (tempCodePoint > 65535 && tempCodePoint < 1114112) { codePoint = tempCodePoint } } } } if (codePoint === null) { codePoint = 65533; bytesPerSequence = 1 } else if (codePoint > 65535) { codePoint -= 65536; res.push(codePoint >>> 10 & 1023 | 55296); codePoint = 56320 | codePoint & 1023 } res.push(codePoint); i += bytesPerSequence } return decodeCodePointsArray(res) } var MAX_ARGUMENTS_LENGTH = 4096; function decodeCodePointsArray(codePoints) { var len = codePoints.length; if (len <= MAX_ARGUMENTS_LENGTH) { return String.fromCharCode.apply(String, codePoints) } var res = ""; var i = 0; while (i < len) { res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)) } return res } function asciiSlice(buf, start, end) { var ret = ""; end = Math.min(buf.length, end); for (var i = start; i < end; ++i){ ret += String.fromCharCode(buf[i] & 127) } return ret } function latin1Slice(buf, start, end) { var ret = ""; end = Math.min(buf.length, end); for (var i = start; i < end; ++i){ ret += String.fromCharCode(buf[i]) } return ret } function hexSlice(buf, start, end) { var len = buf.length; if (!start || start < 0) start = 0; if (!end || end < 0 || end > len) end = len; var out = ""; for (var i = start; i < end; ++i){ out += toHex(buf[i]) } return out } function utf16leSlice(buf, start, end) { var bytes = buf.slice(start, end); var res = ""; for (var i = 0; i < bytes.length; i += 2){ res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256) } return res } Buffer.prototype.slice = function slice(start, end) { var len = this.length; start = ~~start; end = end === undefined ? len : ~~end; if (start < 0) { start += len; if (start < 0) start = 0 } else if (start > len) { start = len } if (end < 0) { end += len; if (end < 0) end = 0 } else if (end > len) { end = len } if (end < start) end = start; var newBuf; if (Buffer.TYPED_ARRAY_SUPPORT) { newBuf = this.subarray(start, end); newBuf.__proto__ = Buffer.prototype } else { var sliceLen = end - start; newBuf = new Buffer(sliceLen, undefined); for (var i = 0; i < sliceLen; ++i){ newBuf[i] = this[i + start] } } return newBuf }; function checkOffset(offset, ext, length) { if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint"); if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length") } Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) { offset = offset | 0; byteLength = byteLength | 0; if (!noAssert) checkOffset(offset, byteLength, this.length); var val = this[offset]; var mul = 1; var i = 0; while (++i < byteLength && (mul *= 256)) { val += this[offset + i] * mul } return val }; Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) { offset = offset | 0; byteLength = byteLength | 0; if (!noAssert) { checkOffset(offset, byteLength, this.length) } var val = this[offset + --byteLength]; var mul = 1; while (byteLength > 0 && (mul *= 256)) { val += this[offset + --byteLength] * mul } return val }; Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) { if (!noAssert) checkOffset(offset, 1, this.length); return this[offset] }; Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) { if (!noAssert) checkOffset(offset, 2, this.length); return this[offset] | this[offset + 1] << 8 }; Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) { if (!noAssert) checkOffset(offset, 2, this.length); return this[offset] << 8 | this[offset + 1] }; Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length); return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216 }; Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length); return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]) }; Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) { offset = offset | 0; byteLength = byteLength | 0; if (!noAssert) checkOffset(offset, byteLength, this.length); var val = this[offset]; var mul = 1; var i = 0; while (++i < byteLength && (mul *= 256)) { val += this[offset + i] * mul } mul *= 128; if (val >= mul) val -= Math.pow(2, 8 * byteLength); return val }; Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) { offset = offset | 0; byteLength = byteLength | 0; if (!noAssert) checkOffset(offset, byteLength, this.length); var i = byteLength; var mul = 1; var val = this[offset + --i]; while (i > 0 && (mul *= 256)) { val += this[offset + --i] * mul } mul *= 128; if (val >= mul) val -= Math.pow(2, 8 * byteLength); return val }; Buffer.prototype.readInt8 = function readInt8(offset, noAssert) { if (!noAssert) checkOffset(offset, 1, this.length); if (!(this[offset] & 128)) return this[offset]; return (255 - this[offset] + 1) * -1 }; Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) { if (!noAssert) checkOffset(offset, 2, this.length); var val = this[offset] | this[offset + 1] << 8; return val & 32768 ? val | 4294901760 : val }; Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) { if (!noAssert) checkOffset(offset, 2, this.length); var val = this[offset + 1] | this[offset] << 8; return val & 32768 ? val | 4294901760 : val }; Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length); return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24 }; Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length); return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3] }; Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length); return read(this, offset, true, 23, 4) }; Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length); return read(this, offset, false, 23, 4) }; Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) { if (!noAssert) checkOffset(offset, 8, this.length); return read(this, offset, true, 52, 8) }; Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) { if (!noAssert) checkOffset(offset, 8, this.length); return read(this, offset, false, 52, 8) }; function checkInt(buf, value, offset, ext, max, min) { if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance'); if (value > max || value < min) throw new RangeError('"value" argument is out of bounds'); if (offset + ext > buf.length) throw new RangeError("Index out of range") } Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) { value = +value; offset = offset | 0; byteLength = byteLength | 0; if (!noAssert) { var maxBytes = Math.pow(2, 8 * byteLength) - 1; checkInt(this, value, offset, byteLength, maxBytes, 0) } var mul = 1; var i = 0; this[offset] = value & 255; while (++i < byteLength && (mul *= 256)) { this[offset + i] = value / mul & 255 } return offset + byteLength }; Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) { value = +value; offset = offset | 0; byteLength = byteLength | 0; if (!noAssert) { var maxBytes = Math.pow(2, 8 * byteLength) - 1; checkInt(this, value, offset, byteLength, maxBytes, 0) } var i = byteLength - 1; var mul = 1; this[offset + i] = value & 255; while (--i >= 0 && (mul *= 256)) { this[offset + i] = value / mul & 255 } return offset + byteLength }; Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) { value = +value; offset = offset | 0; if (!noAssert) checkInt(this, value, offset, 1, 255, 0); if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value); this[offset] = value & 255; return offset + 1 }; function objectWriteUInt16(buf, value, offset, littleEndian) { if (value < 0) value = 65535 + value + 1; for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i){ buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8 } } Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) { value = +value; offset = offset | 0; if (!noAssert) checkInt(this, value, offset, 2, 65535, 0); if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = value & 255; this[offset + 1] = value >>> 8 } else { objectWriteUInt16(this, value, offset, true) } return offset + 2 }; Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) { value = +value; offset = offset | 0; if (!noAssert) checkInt(this, value, offset, 2, 65535, 0); if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = value >>> 8; this[offset + 1] = value & 255 } else { objectWriteUInt16(this, value, offset, false) } return offset + 2 }; function objectWriteUInt32(buf, value, offset, littleEndian) { if (value < 0) value = 4294967295 + value + 1; for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i){ buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255 } } Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) { value = +value; offset = offset | 0; if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0); if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset + 3] = value >>> 24; this[offset + 2] = value >>> 16; this[offset + 1] = value >>> 8; this[offset] = value & 255 } else { objectWriteUInt32(this, value, offset, true) } return offset + 4 }; Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) { value = +value; offset = offset | 0; if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0); if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = value >>> 24; this[offset + 1] = value >>> 16; this[offset + 2] = value >>> 8; this[offset + 3] = value & 255 } else { objectWriteUInt32(this, value, offset, false) } return offset + 4 }; Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) { value = +value; offset = offset | 0; if (!noAssert) { var limit = Math.pow(2, 8 * byteLength - 1); checkInt(this, value, offset, byteLength, limit - 1, -limit) } var i = 0; var mul = 1; var sub = 0; this[offset] = value & 255; while (++i < byteLength && (mul *= 256)) { if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) { sub = 1 } this[offset + i] = (value / mul >> 0) - sub & 255 } return offset + byteLength }; Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) { value = +value; offset = offset | 0; if (!noAssert) { var limit = Math.pow(2, 8 * byteLength - 1); checkInt(this, value, offset, byteLength, limit - 1, -limit) } var i = byteLength - 1; var mul = 1; var sub = 0; this[offset + i] = value & 255; while (--i >= 0 && (mul *= 256)) { if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) { sub = 1 } this[offset + i] = (value / mul >> 0) - sub & 255 } return offset + byteLength }; Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) { value = +value; offset = offset | 0; if (!noAssert) checkInt(this, value, offset, 1, 127, -128); if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value); if (value < 0) value = 255 + value + 1; this[offset] = value & 255; return offset + 1 }; Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) { value = +value; offset = offset | 0; if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768); if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = value & 255; this[offset + 1] = value >>> 8 } else { objectWriteUInt16(this, value, offset, true) } return offset + 2 }; Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) { value = +value; offset = offset | 0; if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768); if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = value >>> 8; this[offset + 1] = value & 255 } else { objectWriteUInt16(this, value, offset, false) } return offset + 2 }; Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) { value = +value; offset = offset | 0; if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648); if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = value & 255; this[offset + 1] = value >>> 8; this[offset + 2] = value >>> 16; this[offset + 3] = value >>> 24 } else { objectWriteUInt32(this, value, offset, true) } return offset + 4 }; Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) { value = +value; offset = offset | 0; if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648); if (value < 0) value = 4294967295 + value + 1; if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = value >>> 24; this[offset + 1] = value >>> 16; this[offset + 2] = value >>> 8; this[offset + 3] = value & 255 } else { objectWriteUInt32(this, value, offset, false) } return offset + 4 }; function checkIEEE754(buf, value, offset, ext, max, min) { if (offset + ext > buf.length) throw new RangeError("Index out of range"); if (offset < 0) throw new RangeError("Index out of range") } function writeFloat(buf, value, offset, littleEndian, noAssert) { if (!noAssert) { checkIEEE754(buf, value, offset, 4) } write(buf, value, offset, littleEndian, 23, 4); return offset + 4 } Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) { return writeFloat(this, value, offset, true, noAssert) }; Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) { return writeFloat(this, value, offset, false, noAssert) }; function writeDouble(buf, value, offset, littleEndian, noAssert) { if (!noAssert) { checkIEEE754(buf, value, offset, 8) } write(buf, value, offset, littleEndian, 52, 8); return offset + 8 } Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) { return writeDouble(this, value, offset, true, noAssert) }; Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) { return writeDouble(this, value, offset, false, noAssert) }; Buffer.prototype.copy = function copy(target, targetStart, start, end) { if (!start) start = 0; if (!end && end !== 0) end = this.length; if (targetStart >= target.length) targetStart = target.length; if (!targetStart) targetStart = 0; if (end > 0 && end < start) end = start; if (end === start) return 0; if (target.length === 0 || this.length === 0) return 0; if (targetStart < 0) { throw new RangeError("targetStart out of bounds") } if (start < 0 || start >= this.length) throw new RangeError("sourceStart out of bounds"); if (end < 0) throw new RangeError("sourceEnd out of bounds"); if (end > this.length) end = this.length; if (target.length - targetStart < end - start) { end = target.length - targetStart + start } var len = end - start; var i; if (this === target && start < targetStart && targetStart < end) { for (i = len - 1; i >= 0; --i){ target[i + targetStart] = this[i + start] } } else if (len < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT) { for (i = 0; i < len; ++i){ target[i + targetStart] = this[i + start] } } else { Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart) } return len }; Buffer.prototype.fill = function fill(val, start, end, encoding) { if (typeof val === "string") { if (typeof start === "string") { encoding = start; start = 0; end = this.length } else if (typeof end === "string") { encoding = end; end = this.length } if (val.length === 1) { var code = val.charCodeAt(0); if (code < 256) { val = code } } if (encoding !== undefined && typeof encoding !== "string") { throw new TypeError("encoding must be a string") } if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) { throw new TypeError("Unknown encoding: " + encoding) } } else if (typeof val === "number") { val = val & 255 } if (start < 0 || this.length < start || this.length < end) { throw new RangeError("Out of range index") } if (end <= start) { return this } start = start >>> 0; end = end === undefined ? this.length : end >>> 0; if (!val) val = 0; var i; if (typeof val === "number") { for (i = start; i < end; ++i){ this[i] = val } } else { var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString()); var len = bytes.length; for (i = 0; i < end - start; ++i){ this[i + start] = bytes[i % len] } } return this }; var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g; function base64clean(str) { str = stringtrim(str).replace(INVALID_BASE64_RE, ""); if (str.length < 2) return ""; while (str.length % 4 !== 0) { str = str + "=" } return str } function stringtrim(str) { if (str.trim) return str.trim(); return str.replace(/^\s+|\s+$/g, "") } function toHex(n) { if (n < 16) return "0" + n.toString(16); return n.toString(16) } function utf8ToBytes(string, units) { units = units || Infinity; var codePoint; var length = string.length; var leadSurrogate = null; var bytes = []; for (var i = 0; i < length; ++i){ codePoint = string.charCodeAt(i); if (codePoint > 55295 && codePoint < 57344) { if (!leadSurrogate) { if (codePoint > 56319) { if ((units -= 3) > -1) bytes.push(239, 191, 189); continue } else if (i + 1 === length) { if ((units -= 3) > -1) bytes.push(239, 191, 189); continue } leadSurrogate = codePoint; continue } if (codePoint < 56320) { if ((units -= 3) > -1) bytes.push(239, 191, 189); leadSurrogate = codePoint; continue } codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536 } else if (leadSurrogate) { if ((units -= 3) > -1) bytes.push(239, 191, 189) } leadSurrogate = null; if (codePoint < 128) { if ((units -= 1) < 0) break; bytes.push(codePoint) } else if (codePoint < 2048) { if ((units -= 2) < 0) break; bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128) } else if (codePoint < 65536) { if ((units -= 3) < 0) break; bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128) } else if (codePoint < 1114112) { if ((units -= 4) < 0) break; bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128) } else { throw new Error("Invalid code point") } } return bytes } function asciiToBytes(str) { var byteArray = []; for (var i = 0; i < str.length; ++i){ byteArray.push(str.charCodeAt(i) & 255) } return byteArray } function utf16leToBytes(str, units) { var c, hi, lo; var byteArray = []; for (var i = 0; i < str.length; ++i){ if ((units -= 2) < 0) break; c = str.charCodeAt(i); hi = c >> 8; lo = c % 256; byteArray.push(lo); byteArray.push(hi) } return byteArray } function base64ToBytes(str) { return toByteArray(base64clean(str)) } function blitBuffer(src, dst, offset, length) { for (var i = 0; i < length; ++i){ if (i + offset >= dst.length || i >= src.length) break; dst[i + offset] = src[i] } return i } function isnan(val) { return val !== val } function isBuffer(obj) { return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj)) } function isFastBuffer(obj) { return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj) } function isSlowBuffer(obj) { return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0)) } function checkUnsignedInt(n) { if (!Array.isArray(n)) { n = [n] } n.forEach(n => { if (!Number.isInteger(n) || n < 0) { throw `invalid integer ${n}` } }) } function arrayEqual(a, b) { if (a === b) return true; if (a == null || b == null) return false; if (a.length !== b.length) return false; for (let i = 0; i < a.length; ++i){ if (a[i] !== b[i]) return false } return true } var __classPrivateFieldSet = undefined && undefined.__classPrivateFieldSet || function (receiver, state, value, kind, f) { if (kind === "m") throw new TypeError("Private method is not writable"); if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter"); if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value }; var __classPrivateFieldGet = undefined && undefined.__classPrivateFieldGet || function (receiver, state, kind, f) { if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter"); if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver) }; var _IssuerParams_P; var ECGroup; (function (ECGroup) { ECGroup["P256"] = "P-256"; ECGroup["P384"] = "P-384"; ECGroup["P521"] = "P-521" })(ECGroup = ECGroup || (ECGroup = {})); class IssuerParams{ constructor(UIDP, descGq, UIDH, g, e, S) { this.UIDP = UIDP; this.descGq = descGq; this.UIDH = UIDH; this.g = g; this.e = e; this.S = S; _IssuerParams_P.set(this, void 0); this.Gq = new Group(this.descGq); const hash = this.Gq.getHash(); hash.update(this.UIDP); this.Gq.updateHash(hash); hash.update(this.g); hash.update(this.e); hash.update(this.S); __classPrivateFieldSet(this, _IssuerParams_P, hash.digest(), "f"); this.P = new Uint8Array } static async create(UIDP, descGq, UIDH, g, e, S) { const parameters = new IssuerParams(UIDP, descGq, UIDH, g, e, S); parameters.P = await __classPrivateFieldGet(parameters, _IssuerParams_P, "f"); return parameters } verify() { if (this.g[0].equals(this.Gq.getIdentity()) || !this.Gq.isValid(this.g[0])) { throw "invalid g0" } } } _IssuerParams_P = new WeakMap; class IssuanceParticipant{ constructor(n) { this.n = n; checkUnsignedInt(n); this.n = n } async computeGamma(A, ip, TI) { const Gq = ip.Gq; const x = await Promise.all(A.map((a, i) => computeXi(i + 1, ip, a))); x.unshift(Gq.Zq.ONE); const xt = await computeXt(ip, TI); x.push(xt); const gamma = Gq.multiModExp(ip.g, x); return gamma } } class Prover extends IssuanceParticipant{ constructor(ip, A, TI, PI, n) { super(n); this.ip = ip; this.A = A; this.TI = TI; this.PI = PI; this.h = []; this.t1 = []; this.t2 = []; this.sigmaZPrime = []; this.sigmaAPrime = []; this.sigmaBPrime = []; this.sigmaCPrime = []; const Gq = ip.Gq; const Zq = Gq.Zq; this.alpha = Zq.getRandomElements(n, true); this.beta1 = Zq.getRandomElements(n); this.beta2 = Zq.getRandomElements(n) } static async create(ip, A, TI, PI, n) { const prover = new Prover(ip, A, TI, PI, n); const gamma = await prover.computeGamma(A, ip, TI); const Gq = prover.ip.Gq; const t1Base = [ip.g[0], Gq.g]; for (let i = 0; i < n; i++){ prover.h.push(Gq.modExp(gamma, prover.alpha[i])); prover.t1.push(Gq.multiModExp(t1Base, [prover.beta1[i], prover.beta2[i]])); prover.t2.push(Gq.modExp(prover.h[i], prover.beta2[i])) } return prover } async createSecondMessage(msg1) { if (this.n != msg1.sA.length || this.n != msg1.sB.length) { throw `invalid first message` } const sigmaC = []; const Gq = this.ip.Gq; const Zq = Gq.Zq; for (let i = 0; i < this.n; i++){ this.sigmaZPrime.push(Gq.modExp(msg1.sZ, this.alpha[i])); this.sigmaAPrime.push(Gq.mul(this.t1[i], msg1.sA[i])); this.sigmaBPrime.push(Gq.multiModExp([this.sigmaZPrime[i], this.t2[i], msg1.sB[i]], [this.beta1[i], Zq.ONE, this.alpha[i]])); const H = Gq.getHash(); H.update(this.h[i]); H.update(this.PI); H.update(this.sigmaZPrime[i]); H.update(this.sigmaAPrime[i]); H.update(this.sigmaBPrime[i]); this.sigmaCPrime.push(Zq.getElement(await H.digest())); sigmaC.push(Zq.add(this.sigmaCPrime[i], this.beta1[i])) } return { sC: sigmaC } } createTokens(msg3, skipValidation = false) { if (this.n != msg3.sR.length) { throw `invalid third message` } const Gq = this.ip.Gq; const Zq = Gq.Zq; const uptk = []; for (let i = 0; i < this.n; i++){ const sigmaRPrime = Zq.add(msg3.sR[i], this.beta2[i]); if (!skipValidation) { const lhs = Gq.mul(this.sigmaAPrime[i], this.sigmaBPrime[i]); const rhs = Gq.multiModExp([Gq.mul(Gq.g, this.h[i]), Gq.mul(this.ip.g[0], this.sigmaZPrime[i])], [sigmaRPrime, Zq.negate(this.sigmaCPrime[i])]); if (!lhs.equals(rhs)) { throw `invalid token ${i}` } } uptk.push({ upt: { UIDP: this.ip.UIDP, h: this.h[i], TI: this.TI, PI: this.PI, sZp: this.sigmaZPrime[i], sCp: this.sigmaCPrime[i], sRp: sigmaRPrime }, alphaInverse: Zq.invert(this.alpha[i]) }) } return uptk } } class Issuer extends IssuanceParticipant{ constructor(ikp, n) { super(n); this.ikp = ikp; this.w = []; this.sigmaA = []; this.sigmaB = []; this.intialized = false; this.Gq = ikp.ip.Gq; this.y0 = ikp.y0 } static async create(ikp, A, TI, n) { const issuer = new Issuer(ikp, n); const Gq = issuer.Gq; const Zq = Gq.Zq; issuer.gamma = await issuer.computeGamma(A, ikp.ip, TI); issuer.sigmaZ = Gq.modExp(issuer.gamma, issuer.y0); issuer.w = Zq.getRandomElements(n); issuer.sigmaA = issuer.w.map(w_i => Gq.modExp(Gq.g, w_i)); issuer.sigmaB = issuer.w.map(w_i => Gq.modExp(issuer.gamma, w_i)); return issuer } createFirstMessage() { return { sZ: this.sigmaZ, sA: this.sigmaA, sB: this.sigmaB } } createThirdMessage(msg2) { if (this.n != msg2.sC.length) { throw `invalid second message` } const Zq = this.Gq.Zq; const sigmaR = this.w.map((w_i, i) => Zq.add(Zq.mul(msg2.sC[i], this.y0), w_i)); return { sR: sigmaR } } } async function createIssuerKeyAndParams(descGq, n, e = undefined, S = new Uint8Array, issKeyPair, UIDP) { if (n < 0 || n > 50) { throw "n must be between 0 and 50" } if (!e) { e = new Array(n).fill(new Byte(1)) } if (e.length != n) { throw "wrong length for e: " + e.length } const groupParams = getEcGroup(descGq); const Gq = groupParams.Gq; const Zq = Gq.Zq; let y0; let g0; if (issKeyPair == undefined) { y0 = Zq.getRandomElement(true); g0 = groupParams.Gq.modExp(Gq.g, y0) } else { y0 = Zq.getElement(issKeyPair.y0); g0 = Gq.getElement(issKeyPair.g0) } const g = groupParams.g.slice(0, n); g.unshift(g0); g.push(groupParams.gt); if (!UIDP) { const hash = new Hash(descGq); hash.update(g); hash.update(e); hash.update(S); UIDP = await hash.digest() } return { ip: await IssuerParams.create(UIDP, descGq, groupToHash(descGq), g, e, S), y0: y0 } } async function computeXt(ip, TI) { const H = ip.Gq.getHash(); H.update(new Byte(1)); H.update(ip.P); H.update(TI); return ip.Gq.Zq.getElement(await H.digest()) } async function computeXi(i, ip, Ai) { const e_i = ip.e[i - 1].b[0]; if (e_i === 1) { const H = ip.Gq.getHash(); return ip.Gq.Zq.getElement(await H.digest(Ai)) } else if (e_i === 0) { const x = ip.Gq.Zq.getElement(Ai); return x } else { throw `invalid e[i] index: ${i}` } } async function verifyTokenSignature(ip, upt) { const Gq = ip.Gq; const Zq = Gq.Zq; if (upt.h.equals(Gq.getIdentity())) { throw `invalid token` } const H = Gq.getHash(); H.update(upt.h); H.update(upt.PI); H.update(upt.sZp); const exponents = [upt.sRp, Zq.negate(upt.sCp)]; H.update(Gq.multiModExp([Gq.g, ip.g[0]], exponents)); H.update(Gq.multiModExp([upt.h, upt.sZp], exponents)); const value = Zq.getElement(await H.digest()); if (!upt.sCp.equals(value)) { throw `invalid token` } } async function generatePresentationProof(ip, D, upkt, m, A, md = new Uint8Array) { const n = A.length; D = sanitizeD(D); const USet = new Set(Array.from({ length: n }, (e, i) => i + 1)); D.forEach(v => USet.delete(v)); const U = Array.from(USet).sort((a, b) => a - b); const Gq = ip.Gq; const Zq = Gq.Zq; const x = await Promise.all(A.map(async (a, i) => await computeXi(i + 1, ip, a))); const w0 = Zq.getRandomElement(); const w = Zq.getRandomElements(n - D.length); const H = Gq.getHash(); const a = await H.digest(Gq.multiModExp([upkt.upt.h, ...ip.g.slice(1, n + 1).filter((g, i) => U.includes(i + 1))], [w0, ...w])); const challengeData = await computePresentationChallenge(Gq, upkt.upt, a, D, x.filter((x, i) => D.includes(i + 1)), m, md); const negC = Zq.negate(challengeData.c); const r = [Zq.add(Zq.mul(challengeData.c, upkt.alphaInverse), w0)]; for (let i = 0; i < U.length; i++){ r.push(Zq.add(Zq.mul(negC, x[U[i] - 1]), w[i])) } const disclosedA = {}; for (const d of D) { disclosedA[d] = A[d - 1] } return { UIDT: challengeData.UIDT, pp: { A: disclosedA, a: a, r: r } } } async function verifyPresentationProof(ip, upt, m, pp, md = new Uint8Array) { const Gq = ip.Gq; const Zq = Gq.Zq; await verifyTokenSignature(ip, upt); const xt = await computeXt(ip, upt.TI); let D = []; let x = []; if (pp.A) { x = await Promise.all(Object.entries(pp.A).map(([iStr, Ai]) => { const i = parseInt(iStr); D.push(i); return computeXi(i, ip, Ai) })); D = D.sort((a, b) => a - b); x = D.map(i => x[D.indexOf(i)]) } const challengeData = await computePresentationChallenge(Gq, upt, pp.a, D, x, m, md); const t = ip.g.length - 1; const base0 = Gq.multiModExp([ip.g[0], ...ip.g.filter((g, i) => D.includes(i)), ip.g[t]], [Zq.ONE, ...x, xt]); const hashInput = Gq.multiModExp([base0, upt.h, ...ip.g.slice(1, t).filter((g, i) => !D.includes(i + 1))], [Zq.negate(challengeData.c), pp.r[0], ...pp.r.slice(1)]); if (!arrayEqual(pp.a, await Gq.getHash().digest(hashInput))) { throw `invalid presentation proof` } return { UIDT: challengeData.UIDT } } async function computeTokenId(Gq, upt) { const H = Gq.getHash(); H.update(upt.h); H.update(upt.sZp); H.update(upt.sCp); H.update(upt.sRp); return await H.digest() } async function computePresentationChallenge(Gq, upt, a, D, xInD, m, md) { const UIDT = await computeTokenId(Gq, upt); let H = Gq.getHash(); H.update(UIDT); H.update(a); H.update(D); H.update(xInD); H.update([]); H.update([]); H.update([]); H.update(0); H.update(null); H.update(null); H.update(m); const cp = await H.digest(); H = Gq.getHash(); H.update([cp, md]); return { UIDT: UIDT, c: Gq.Zq.getElement(await H.digest()) } } function sanitizeD(D) { checkUnsignedInt(D); const SetD = new Set(D); D = Array.from(SetD).sort((a, b) => a - b); return D } var uprove = Object.freeze({ __proto__: null, get ECGroup() { return ECGroup }, IssuanceParticipant: IssuanceParticipant, Issuer: Issuer, IssuerParams: IssuerParams, Prover: Prover, computeXi: computeXi, computeXt: computeXt, createIssuerKeyAndParams: createIssuerKeyAndParams, generatePresentationProof: generatePresentationProof, verifyPresentationProof: verifyPresentationProof, verifyTokenSignature: verifyTokenSignature }); const crypto$1 = globalThis.crypto; class FieldZqElement{ constructor(scalar) { this.scalar = scalar } getBytes() { const bytes = cryptoMathExports.digitsToBytes(this.scalar.m_digits); return new Uint8Array(bytes) } equals(e) { return this.scalar.equals(e.scalar) } } class FieldZq{ constructor(q) { this.q = q; const qBytes = cryptoMathExports.digitsToBytes(q); this.elementLength = qBytes.length; this.Zq = new cryptoMathExports.IntegerGroup(qBytes); this.ZERO = new FieldZqElement(this.Zq.createElementFromInteger(0)); this.ONE = new FieldZqElement(this.Zq.createElementFromInteger(1)) } getElement(encoded) { let digits = cryptoMathExports.bytesToDigits(Array.from(encoded)); const result = cryptoMathExports.intToDigits(0); while (cryptoMathExports.compareDigits(digits, this.q) >= 0) { cryptoMathExports.subtract(digits, this.q, result); digits = result } return new FieldZqElement(this.Zq.createElementFromDigits(digits)) } getRandomElement(nonZero = false) { let done = false; let randZq = cryptoMathExports.Zero; while (!done) { const ranBytes = crypto$1.getRandomValues(new Uint8Array(this.elementLength)); randZq = cryptoMathExports.bytesToDigits(Array.from(ranBytes)); if (cryptoMathExports.compareDigits(randZq, this.q) < 0) { done = true } if (nonZero && cryptoMathExports.isZero(randZq)) { done = false } } return new FieldZqElement(this.Zq.createElementFromDigits(randZq)) } getRandomElements(n, nonZero = false) { const r = []; for (let i = 0; i < n; i++){ r.push(this.getRandomElement(nonZero)) } return r } add(a, b) { const sum = this.Zq.createElementFromInteger(0); this.Zq.add(a.scalar, b.scalar, sum); return new FieldZqElement(sum) } mul(a, b) { const product = this.Zq.createElementFromInteger(0); this.Zq.multiply(a.scalar, b.scalar, product); return new FieldZqElement(product) } negate(a) { const minusA = this.Zq.createElementFromInteger(0); this.Zq.subtract(this.Zq.createElementFromInteger(0), a.scalar, minusA); return new FieldZqElement(minusA) } invert(a) { const aInverse = this.Zq.createElementFromInteger(0); this.Zq.inverse(a.scalar, aInverse); return new FieldZqElement(aInverse) } } class GroupElement{ constructor(point) { this.point = point } getBytes() { const encoded = cryptoECCExports.sec1EncodingFp().encodePoint(this.point); return new Uint8Array(encoded) } equals(e) { return this.point.equals(e.point) } } var CurveNames; (function (CurveNames) { CurveNames["P256"] = "P-256"; CurveNames["P384"] = "P-384"; CurveNames["P521"] = "P-521" })(CurveNames || (CurveNames = {})); const P256Curve = cryptoECCExports.createCurve(CurveNames.P256); const P384Curve = cryptoECCExports.createCurve(CurveNames.P384); const P521Curve = cryptoECCExports.createCurve(CurveNames.P521); class Group{ constructor(descGq) { if (descGq == ECGroup.P256) { this.curve = P256Curve } else if (descGq == ECGroup.P384) { this.curve = P384Curve } else if (descGq == ECGroup.P521) { this.curve = P521Curve } else { throw "invalid group description" } this.ecOperator = cryptoECCExports.EllipticCurveOperatorFp(this.curve); this.Zq = new FieldZq(this.curve.order); this.g = new GroupElement(this.curve.generator); this.descGq = descGq } getHash() { return new Hash(this.descGq) } updateHash(H) { H.update(new Uint8Array(cryptoMathExports.digitsToBytes(this.curve.p))); H.update(new Uint8Array(cryptoMathExports.digitsToBytes(this.curve.a))); H.update(new Uint8Array(cryptoMathExports.digitsToBytes(this.curve.b))); H.update(this.g); H.update(new Uint8Array(cryptoMathExports.digitsToBytes(this.curve.order))); H.update(new Uint8Array([1])) } parsePoint(x, y) { const point = new cryptoECCExports.EllipticCurvePointFp(this.curve, false, cryptoMathExports.bytesToDigits(x), cryptoMathExports.bytesToDigits(y)); return new GroupElement(point) } getElement(encoded) { return new GroupElement(cryptoECCExports.sec1EncodingFp().decodePoint(Array.from(encoded), this.curve)) } getIdentity() { return new GroupElement(this.curve.createPointAtInfinity()) } mul(a, b) { const pointA = a.point; const pointB = pointA === b.point ? b.point.clone() : b.point; const temp = this.curve.allocatePointStorage(); this.ecOperator.convertToMontgomeryForm(temp); this.ecOperator.convertToJacobianForm(temp); if (!pointA.isInMontgomeryForm) this.ecOperator.convertToMontgomeryForm(pointA); if (pointA.isAffine) this.ecOperator.convertToJacobianForm(pointA); if (!pointB.isAffine) this.ecOperator.convertToAffineForm(pointB); if (!pointB.isInMontgomeryForm) this.ecOperator.convertToMontgomeryForm(pointB); this.ecOperator.mixedAdd(pointA, pointB, temp); this.ecOperator.convertToAffineForm(pointA); this.ecOperator.convertToStandardForm(pointA); this.ecOperator.convertToStandardForm(pointB); this.ecOperator.convertToAffineForm(temp); this.ecOperator.convertToStandardForm(temp); return new GroupElement(temp) } modExp(g, e) { const result = this.curve.allocatePointStorage(); if (!g.point.isAffine) this.ecOperator.convertToAffineForm(g.point); if (!g.point.isInMontgomeryForm) this.ecOperator.convertToMontgomeryForm(g.point); this.ecOperator.scalarMultiply(e.scalar.m_digits, g.point, result); if (!g.point.isAffine) this.ecOperator.convertToAffineForm(g.point); if (g.point.isInMontgomeryForm) this.ecOperator.convertToStandardForm(g.point); if (!result.isAffine) this.ecOperator.convertToAffineForm(result); if (result.isInMontgomeryForm) this.ecOperator.convertToStandardForm(result); return new GroupElement(result) } multiModExp(g, e) { if (g.length !== e.length) { throw `g and e length mismatch` } let result = this.getIdentity(); for (let i = 0; i < g.length; i++){ const temp = this.modExp(g[i], e[i]); result = this.mul(result, temp) } return result } isValid(g) { return this.ecOperator.validatePoint(g.point) } } const crypto = globalThis.crypto; const groupToHash = g => { switch (g) { case ECGroup.P256: return "sha256"; case ECGroup.P384: return "sha384"; case ECGroup.P521: return "sha512"; default: throw "invalid group" } }; class Byte{ constructor(b) { if (0 < b && b > 255) throw "invalid byte value" + b; this.b = new Uint8Array([b]) } } class Hash{ constructor(descGq) { this.hash = new Uint8Array(0); this.descGq = descGq } getIntArray(n) { return new Uint8Array([n >> 24, n >> 16, n >> 8, n]) } updateInternal(data) { const temp = new Uint8Array(this.hash.length + data.length); temp.set(this.hash); temp.set(data, this.hash.length); this.hash = temp } update(data) { if (Array.isArray(data)) { this.update(data.length); data.forEach(v => this.update(v)) } else if (data instanceof Byte) { this.updateInternal(data.b) } else if (data === null) { this.updateInternal(this.getIntArray(0)) } else if (typeof data === "number") { this.updateInternal(this.getIntArray(data)) } else if (data instanceof Uint8Array) { this.updateInternal(this.getIntArray(data.length)); this.updateInternal(data) } else if (data instanceof GroupElement) { this.update(data.getBytes()) } else if (data instanceof FieldZqElement) { this.update(data.getBytes()) } else { throw "invalid input" } } digest(data = undefined) { if (data || data === null) { this.update(data) } return crypto.subtle.digest({ name: groupToHash(this.descGq).replace("sha", "sha-") }, this.hash).then(arrayBuffer => { return new Uint8Array(arrayBuffer) }) } } function encodeIssuerParams(ip) { return { UIDP: toBase64Url(ip.UIDP), dGq: ip.descGq, UIDH: ip.UIDH, g0: toBase64Url(ip.g[0].getBytes()), e: ip.e.map(e => e.b[0]), S: toBase64Url(ip.S) } } async function decodeIssuerParams(ipJSON) { const n = ipJSON.e.length; let descGq = ECGroup.P256; switch (ipJSON.dGq) { case ECGroup.P256: descGq = ECGroup.P256; break; case ECGroup.P384: descGq = ECGroup.P384; break; case ECGroup.P521: descGq = ECGroup.P521; break }const groupParams = getEcGroup(descGq); const Gq = groupParams.Gq; const g = groupParams.g.slice(0, n); g.unshift(Gq.getElement(fromBase64Url(ipJSON.g0))); g.push(groupParams.gt); return await IssuerParams.create(fromBase64Url(ipJSON.UIDP), descGq, ipJSON.UIDH, g, ipJSON.e.map(e => new Byte(e)), fromBase64Url(ipJSON.S)) } function encodeUProveToken(upt) { return { UIDP: toBase64Url(upt.UIDP), h: toBase64Url(upt.h.getBytes()), TI: toBase64Url(upt.TI), PI: toBase64Url(upt.PI), sZp: toBase64Url(upt.sZp.getBytes()), sCp: toBase64Url(upt.sCp.getBytes()), sRp: toBase64Url(upt.sRp.getBytes()) } } function decodeUProveToken(ip, uptJSON) { const Gq = ip.Gq; const Zq = Gq.Zq; return { UIDP: fromBase64Url(uptJSON.UIDP), h: Gq.getElement(fromBase64Url(uptJSON.h)), TI: fromBase64Url(uptJSON.TI), PI: fromBase64Url(uptJSON.PI), sZp: Gq.getElement(fromBase64Url(uptJSON.sZp)), sCp: Zq.getElement(fromBase64Url(uptJSON.sCp)), sRp: Zq.getElement(fromBase64Url(uptJSON.sRp)) } } function encodeFirstIssuanceMessage(m1) { return { sZ: toBase64Url(m1.sZ.getBytes()), sA: m1.sA.map(sigmaA => toBase64Url(sigmaA.getBytes())), sB: m1.sB.map(sigmaB => toBase64Url(sigmaB.getBytes())) } } function decodeFirstIssuanceMessage(ip, m1JSON) { const Gq = ip.Gq; return { sZ: Gq.getElement(fromBase64Url(m1JSON.sZ)), sA: m1JSON.sA.map(sigmaA => Gq.getElement(fromBase64Url(sigmaA))), sB: m1JSON.sB.map(sigmaB => Gq.getElement(fromBase64Url(sigmaB))) } } function encodeSecondIssuanceMessage(m2) { return { sC: m2.sC.map(sigmaC => toBase64Url(sigmaC.getBytes())) } } function decodeSecondIssuanceMessage(ip, m2JSON) { const Zq = ip.Gq.Zq; return { sC: m2JSON.sC.map(sigmaC => Zq.getElement(fromBase64Url(sigmaC))) } } function encodeThirdIssuanceMessage(m3) { return { sR: m3.sR.map(sigmaR => toBase64Url(sigmaR.getBytes())) } } function decodeThirdIssuanceMessage(ip, m3JSON) { const Zq = ip.Gq.Zq; return { sR: m3JSON.sR.map(sigmaR => Zq.getElement(fromBase64Url(sigmaR))) } } function encodePresentationProof(pp) { const ppJSON = { a: toBase64Url(pp.a), r: pp.r.map(r => toBase64Url(r.getBytes())) }; if (pp.A && Object.keys(pp.A).length > 0) { ppJSON.A = Object.entries(pp.A).reduce((acc, [i, Ai]) => { acc[Number(i)] = toBase64Url(Ai); return acc }, {}) } return ppJSON } function decodePresentationProof(ip, ppJSON) { const Zq = ip.Gq.Zq; const pp = { a: fromBase64Url(ppJSON.a), r: ppJSON.r.map(r => Zq.getElement(fromBase64Url(r))) }; if (ppJSON.A) { pp.A = Object.entries(ppJSON.A).reduce((acc, [i, Ai]) => { acc[Number(i)] = fromBase64Url(Ai); return acc }, {}) } return pp } function encodeUIDT(UIDT) { return toBase64Url(UIDT) } function dncodeUIDT(UIDT) { return fromBase64Url(UIDT) } var serialization = Object.freeze({ __proto__: null, decodeFirstIssuanceMessage: decodeFirstIssuanceMessage, decodeIssuerParams: decodeIssuerParams, decodePresentationProof: decodePresentationProof, decodeSecondIssuanceMessage: decodeSecondIssuanceMessage, decodeThirdIssuanceMessage: decodeThirdIssuanceMessage, decodeUProveToken: decodeUProveToken, dncodeUIDT: dncodeUIDT, encodeFirstIssuanceMessage: encodeFirstIssuanceMessage, encodeIssuerParams: encodeIssuerParams, encodePresentationProof: encodePresentationProof, encodeSecondIssuanceMessage: encodeSecondIssuanceMessage, encodeThirdIssuanceMessage: encodeThirdIssuanceMessage, encodeUIDT: encodeUIDT, encodeUProveToken: encodeUProveToken }); const toBase64Url = a => Buffer.from(a).toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, ""); const fromBase64Url = b64 => Buffer.from(b64, "base64"); var ExpirationType; (function (ExpirationType) { ExpirationType["sec"] = "sec"; ExpirationType["hour"] = "hour"; ExpirationType["day"] = "day"; ExpirationType["week"] = "week"; ExpirationType["year"] = "year" })(ExpirationType = ExpirationType || (ExpirationType = {})); const MS_PER_SECOND = 1e3; const MS_PER_HOUR = MS_PER_SECOND * 60 * 60; const MS_PER_DAY = MS_PER_HOUR * 24; const MS_PER_WEEK = MS_PER_DAY * 7; const MS_PER_YEAR = MS_PER_WEEK * 52; function msToTypedTime(type, t) { let typedT; switch (type) { case ExpirationType.sec: typedT = t / MS_PER_SECOND; break; case ExpirationType.hour: typedT = t / MS_PER_HOUR; break; case ExpirationType.day: typedT = t / MS_PER_DAY; break; case ExpirationType.week: typedT = t / MS_PER_WEEK; break; case ExpirationType.year: typedT = t / MS_PER_YEAR; break }return typedT } function getExp(type, t, start = undefined) { checkUnsignedInt(t); if (start) { checkUnsignedInt(start) } else { start = Math.ceil(msToTypedTime(type, Date.now())) } return start + t } function isExpired(type, exp, target = undefined) { if (!target) { target = msToTypedTime(type, Date.now()) } return target > exp } function parseSpecification(S) { const spec = JSON.parse(S.toString()); return spec } async function createIssuerKeyAndParamsUPJF(descGq, specification, issKeyPair) { const n = specification.n; checkUnsignedInt(n); if (n < 0 || n > 50) throw `${n} is not a valid value for n, must between 0 and 50 inclusively`; return await createIssuerKeyAndParams(descGq, n, undefined, Buffer.from(JSON.stringify(specification)), issKeyPair, undefined) } var UPAlg; (function (UPAlg) { UPAlg["UP256"] = "UP256"; UPAlg["UP384"] = "UP384"; UPAlg["UP521"] = "UP521" })(UPAlg = UPAlg || (UPAlg = {})); function encodePrivateKeyAsBase64Url(y0) { return toBase64Url(y0.getBytes()) } function decodeBase64UrlAsPrivateKey(ip, b64) { return ip.Gq.Zq.getElement(fromBase64Url(b64)) } function descGqToUPAlg(descGq) { switch (descGq) { case ECGroup.P256: return UPAlg.UP256; case ECGroup.P384: return UPAlg.UP384; case ECGroup.P521: return UPAlg.UP521 } } function encodeIPAsJWK(ip) { return { kty: "UP", alg: descGqToUPAlg(ip.descGq), kid: toBase64Url(ip.UIDP), g0: toBase64Url(ip.g[0].getBytes()), spec: toBase64Url(ip.S) } } async function decodeJWKAsIP(jwk) { if (jwk.kty !== "UP") { throw `${jwk.kty} is not a valid key type, "UP" expected` } let descGq; switch (jwk.alg) { case UPAlg.UP256: descGq = ECGroup.P256; break; case UPAlg.UP384: descGq = ECGroup.P384; break; case UPAlg.UP521: descGq = ECGroup.P521; break; default: throw `${jwk.alg} is not a valid algorithm` }const SBytes = fromBase64Url(jwk.spec); const spec = JSON.parse(SBytes.toString()); const n = spec.n; const groupParams = getEcGroup(descGq); const Gq = groupParams.Gq; const g = groupParams.g.slice(0, n); g.unshift(Gq.getElement(fromBase64Url(jwk.g0))); g.push(groupParams.gt); const e = jwk.e ? jwk.e : new Array(n).fill(1); return await IssuerParams.create(fromBase64Url(jwk.kid), descGq, groupToHash(descGq), g, e.map(e => new Byte(e)), SBytes) } function parseTokenInformation(TI) { const tokenInformation = JSON.parse(TI.toString()); return tokenInformation } function encodeTokenInformation(TI) { return Buffer.from(JSON.stringify(TI)) } function createJWS(alg, m, tp) { const header = toBase64Url(Buffer.from(JSON.stringify({ alg: alg }))); const payload = toBase64Url(m); const sig = toBase64Url(Buffer.from(JSON.stringify(tp))); return header + "." + payload + "." + sig } function parseJWS(jws) { const parts = jws.split("."); if (!parts || parts.length != 3) { throw "can't parse jws into 3 parts" } try { const upJws = { header: JSON.parse(Buffer.from(parts[0], "base64").toString("utf8")), payload: Buffer.from(parts[1], "base64"), sig: JSON.parse(Buffer.from(parts[2], "base64").toString("utf8")) }; return upJws } catch (err) { throw "can't parse jws" + err } } var upjf = Object.freeze({ __proto__: null, get ExpirationType() { return ExpirationType }, get UPAlg() { return UPAlg }, createIssuerKeyAndParamsUPJF: createIssuerKeyAndParamsUPJF, createJWS: createJWS, decodeBase64UrlAsPrivateKey: decodeBase64UrlAsPrivateKey, decodeJWKAsIP: decodeJWKAsIP, descGqToUPAlg: descGqToUPAlg, encodeIPAsJWK: encodeIPAsJWK, encodePrivateKeyAsBase64Url: encodePrivateKeyAsBase64Url, encodeTokenInformation: encodeTokenInformation, getExp: getExp, isExpired: isExpired, msToTypedTime: msToTypedTime, parseJWS: parseJWS, parseSpecification: parseSpecification, parseTokenInformation: parseTokenInformation }); var lib = { uprove: uprove, serialization: serialization, upjf: upjf, Buffer: Buffer, Byte: Byte }; export { lib as default };